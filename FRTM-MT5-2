//+------------------------------------------------------------------+
//|                                           ForexRiskManager.mq5    |
//|                                  Risk Management & Lot Calculator |
//|                                                                    |
//+------------------------------------------------------------------+
#property copyright "Forex Risk Manager"
#property link      ""
#property version   "1.02"
#property description "Risk Management EA with Lot Size Calculator"
#property description "Ideal & Conservative Modes | One-Click Execution"

//--- Include libraries
#include <Trade\Trade.mqh>
CTrade trade;

//+------------------------------------------------------------------+
//| Enumerations - MUST BE BEFORE INPUTS                            |
//+------------------------------------------------------------------+
enum ENUM_PIP_MODE
{
   PIP_AUTO,           // Auto Calculate
   PIP_MANUAL          // Manual Entry
};

enum ENUM_SL_MODE
{
   SL_MANUAL,          // Manual (Fixed Pips)
   SL_DYNAMIC          // Dynamic (to Price Level)
};

enum ENUM_TP_MODE
{
   TP_RR_MULTIPLE,     // Risk/Reward Multiple
   TP_DYNAMIC          // Dynamic (to Price Level)
};

enum ENUM_TP_METHOD
{
   TP_STANDARD,        // Standard TP
   TP_PARTIAL_EXITS    // Partial Exits
};

enum ENUM_PARTIAL_METHOD
{
   PARTIAL_RR,         // RR Multiples
   PARTIAL_MANUAL      // Manual Levels
};

enum ENUM_DISPLAY_MODE
{
   DISPLAY_IDEAL,           // Ideal (No Entry Slippage)
   DISPLAY_CONSERVATIVE     // Conservative (With Entry Slippage)
};

enum ENUM_TRADE_DIR
{
   TRADE_BUY,    // Buy (Long)
   TRADE_SELL    // Sell (Short)
};

enum ENUM_LABEL_POSITION
{
   LABEL_RIGHT,      // Right of line
   LABEL_ABOVE,      // Above line
   LABEL_BELOW       // Below line
};

//+------------------------------------------------------------------+
//| Input Parameters                                                  |
//+------------------------------------------------------------------+

//--- Trade Management Mode
input group "===== Trade Management ====="
input bool inpTradeManagementMode = false;                  // Trade Management Mode (Hide Planning Lines)
input bool inpPlaceSLTP = true;                             // Place SL/TP with Orders
input bool inpAutoMoveToBE_Standard = false;                // Auto Move SL to BE (Standard TP)
input double inpBETriggerPrice = 0.0;                       // BE Trigger Price Level
input double inpBEOffsetPips = 0.0;                         // BE Offset (pips above/below entry)
input bool inpAutoMoveToBE_Partial = false;                 // Auto Move SL to BE (Partial Exits)
input int inpBETriggerLevel = 1;                            // BE Trigger at TP Level (1, 2, or 3)
input bool inpBEEnableAlert = true;                         // Enable Alert Notification
input bool inpBEEnableSound = true;                         // Enable Sound Notification
input bool inpBEEnablePush = true;                          // Enable Push Notification
input string inpBESoundFile = "alert.wav";                  // Sound File Name

//--- Stop Loss Settings
input group "===== Stop Loss Settings ====="
input ENUM_SL_MODE inpSLMode = SL_MANUAL;                    // Stop Loss Mode
input double inpManualSLPips = 15.0;                         // Manual Stop Loss (pips)
input ENUM_TRADE_DIR inpTradeDirection = TRADE_BUY;          // Trade Direction (Manual SL Mode)

//--- Take Profit Settings
input group "===== Take Profit Settings ====="
input bool inpShowTP = true;                                 // Show Take Profit Lines
input ENUM_TP_METHOD inpTPMethod = TP_STANDARD;             // Take Profit Method
input ENUM_TP_MODE inpTPMode = TP_RR_MULTIPLE;              // Take Profit Mode (Standard)
input double inpRRMultiple = 2.0;                           // Risk/Reward Multiple (Standard)

//--- Partial Exits Settings
input group "===== Partial Exits ====="
input int inpNumberOfLevels = 3;                            // Number of Exit Levels (2 or 3)
input ENUM_PARTIAL_METHOD inpPartialMethod = PARTIAL_RR;    // Partial Exit Method
input double inpExitPercent1 = 50.0;                        // Exit % at Level 1
input double inpExitPercent2 = 30.0;                        // Exit % at Level 2

//--- Partial Exits - RR Multiples
input group "===== Partial Exits - RR Multiples ====="
input double inpRRTarget1 = 1.0;                            // Level 1 RR Multiple
input double inpRRTarget2Overall = 1.5;                     // Level 2 Overall RR
input double inpRRTarget3Overall = 2.0;                     // Level 3 Overall RR

//--- Account & Risk Settings
input group "===== Account & Risk Settings ====="
input double inpAccountSize = 100000;                       // Account Size (USD)
input double inpRiskPercent = 0.25;                         // Risk % per Trade
input double inpMarginPercent = 3.0;                        // Margin Requirement %
input double inpCommissionPerLot = 5.0;                     // Commission per Lot (Round-turn USD)
input ENUM_PIP_MODE inpPipValueMode = PIP_AUTO;            // Pip Value Mode
input double inpManualPipValue = 10.0;                      // Manual Pip Value (USD per lot)
input bool inpShowPipValue = true;                          // Show Pip Value in Panel

//--- Entry & Exit Slippage Settings
input group "===== Entry & Exit Slippage ====="
input double inpEntrySlippage = 0.2;                        // Expected Entry Slippage (pips)
input double inpExitSlippage = 0.1;                         // Expected Exit Slippage (pips)
input ENUM_DISPLAY_MODE inpDisplayMode = DISPLAY_CONSERVATIVE; // Display Mode
input bool inpShowAlternateLotSize = false;                 // Show Alternate Lot Size

//--- Display Settings
input group "===== Display Settings ====="
input bool inpShowPanel = true;                             // Show Information Panel
input bool inpShowLines = true;                             // Show Reference Lines
input bool inpShowEntryLine = true;                         // Show Entry Line
input bool inpShowBreakEvenLine = false;                    // Show Break-even Line
input bool inpShowReturnOnMargin = false;                   // Show Return on Margin
input int inpPanelX = 20;                                   // Panel X Position
input int inpPanelY = 80;                                   // Panel Y Position
input color inpPanelBgColor = clrWhite;                     // Panel Background Color
input color inpPanelTextColor = clrBlack;                   // Panel Text Color
input color inpSLLineColor = clrRed;                        // Stop Loss Line Color
input color inpTPLineColor = clrGreen;                      // Take Profit Line Color
input color inpEntryLineColor = clrBlue;                    // Entry Line Color
input color inpBELineColor = clrOrange;                     // Break-even Line Color
input ENUM_LABEL_POSITION inpLabelPosition = LABEL_ABOVE;   // Label Position (Dynamic Mode)

//--- Button Settings
input group "===== Button Settings ====="
input int inpButtonWidth = 135;                             // Button Width
input int inpButtonHeight = 30;                             // Button Height
input color inpBuyButtonColor = C'0,128,0';                 // Buy Button Color
input color inpSellButtonColor = C'178,34,34';              // Sell Button Color

//+------------------------------------------------------------------+
//| Global Variables                                                  |
//+------------------------------------------------------------------+
string g_PanelName = "RiskPanel";
string g_BuyButtonName = "BuyButton";
string g_SellButtonName = "SellButton";
string g_SLLineName = "SLLine";
string g_TPLineName = "TPLine";
string g_EntryLineName = "EntryLine";
string g_BELineName = "BELine";
string g_PartialTP1LineName = "PartialTP1Line";
string g_PartialTP2LineName = "PartialTP2Line";
string g_PartialTP3LineName = "PartialTP3Line";
string g_SLLabelName = "SLLine_Label";          // Text label for draggable SL
string g_TPLabelName = "TPLine_Label";          // Text label for TP
string g_PartialTP1LabelName = "PartialTP1Line_Label";  // Text label for Partial TP1
string g_PartialTP2LabelName = "PartialTP2Line_Label";  // Text label for Partial TP2
string g_PartialTP3LabelName = "PartialTP3Line_Label";  // Text label for Partial TP3

double g_PointValue;
double g_PipValue;
int g_Digits;
double g_Point;

// Calculation results
struct RiskCalculation
{
   double lotSize;
   double priceRisk;
   double commission;
   double totalRisk;
   double riskPercent;
   double slPips;
   double baseSLPips;      // Original SL distance (without entry slippage)
   double tpPips;
   double slPrice;
   double tpPrice;
   double entryPrice;
   double breakEvenPips;
   double grossTP;
   double netTP;
   double marginRequired;
   double buyingPowerPercent;
   double returnOnMargin;
   
   // Partial exits
   double partialLots1;
   double partialLots2;
   double partialLots3;
   double partialPips1;
   double partialPips2;
   double partialPips3;
   double partialTP1Price;
   double partialTP2Price;
   double partialTP3Price;
   double partialNetPnL1;
   double partialNetPnL2;
   double partialNetPnL3;
   double partialTotalNetPnL;
};

RiskCalculation g_IdealCalc;
RiskCalculation g_ConservativeCalc;

//+------------------------------------------------------------------+
//| Expert initialization function                                    |
//+------------------------------------------------------------------+
int OnInit()
{
   //--- Initialize symbol info
   g_Digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
   g_Point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   //--- Calculate pip value
   string baseCurrency = SymbolInfoString(_Symbol, SYMBOL_CURRENCY_BASE);
   string quoteCurrency = SymbolInfoString(_Symbol, SYMBOL_CURRENCY_PROFIT);
   
   // Determine pip size
   if(StringFind(baseCurrency, "JPY") >= 0 || StringFind(quoteCurrency, "JPY") >= 0)
      g_PipValue = 0.01;
   else if(g_Digits == 5 || g_Digits == 3)
      g_PipValue = g_Point * 10;
   else
      g_PipValue = g_Point;
   
   //--- Calculate point value per standard lot (USD per point per lot)
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double contractSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_CONTRACT_SIZE);
   
   if(tickSize != 0 && tickValue != 0)
      g_PointValue = (tickValue / tickSize) * g_Point;
   else
   {
      // Fallback calculation
      double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      if(quoteCurrency == "USD")
         g_PointValue = g_Point * contractSize; // Direct USD quote
      else
         g_PointValue = (g_Point * contractSize) / bid; // Cross pair
   }
   
   // Use manual pip value if mode is set to manual
   double pipValuePerLot = (inpPipValueMode == PIP_MANUAL) ? inpManualPipValue : (g_PointValue * (g_PipValue / g_Point));
   
   Print("Symbol: ", _Symbol);
   Print("Digits: ", g_Digits);
   Print("Point: ", g_Point);
   Print("Pip Value: ", g_PipValue);
   Print("Point Value per lot: $", g_PointValue);
   Print("Pip Value per lot: $", pipValuePerLot);
   Print("Pip Value Mode: ", (inpPipValueMode == PIP_MANUAL ? "Manual" : "Auto"));
   Print("Base Currency: ", baseCurrency);
   Print("Quote Currency: ", quoteCurrency);
   Print("Contract Size: ", contractSize);
   Print("Tick Size: ", tickSize);
   Print("Tick Value: ", tickValue);
   
   //--- Create UI
   CreatePanel();
   CreateButtons();
   
   //--- Initial calculation
   CalculateRisk();
   UpdatePanel();
   UpdateLines();
   
   //--- Set timer for updates
   EventSetTimer(1);
   
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   //--- Kill timer
   EventKillTimer();

   //--- Delete all objects
   DeletePanel();
   DeleteButtons();
   DeleteLines();

   //--- Delete actual order lines
   for(int i = ObjectsTotal(0, 0, OBJ_TREND) - 1; i >= 0; i--)
   {
      string objName = ObjectName(0, i, 0, OBJ_TREND);
      if(StringFind(objName, "ActualEntry_") == 0 || StringFind(objName, "ActualBE_") == 0)
         ObjectDelete(0, objName);
   }
}

//+------------------------------------------------------------------+
//| Manage Break-Even Automation                                     |
//+------------------------------------------------------------------+
void ManageBreakEven()
{
   // Exit if both BE features are disabled
   if(!inpAutoMoveToBE_Partial && !inpAutoMoveToBE_Standard)
      return;

   // Loop through all positions
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket <= 0) continue;

      // Filter: only process positions for this symbol and magic number
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      if(PositionGetInteger(POSITION_MAGIC) != 123456) continue;

      // Get position details
      double entryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double currentSL = PositionGetDouble(POSITION_SL);
      double currentTP = PositionGetDouble(POSITION_TP);
      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      string comment = PositionGetString(POSITION_COMMENT);

      // Determine which calculation to use based on comment
      bool useConservative = (StringFind(comment, "_CONS") >= 0);
      RiskCalculation calc = useConservative ? g_ConservativeCalc : g_IdealCalc;

      double triggerPrice = 0.0;
      bool shouldMoveToBE = false;

      // ===== PARTIAL EXITS MODE =====
      if(inpAutoMoveToBE_Partial && inpTPMethod == TP_PARTIAL_EXITS)
      {
         // Determine trigger price based on level
         if(inpBETriggerLevel == 1)
            triggerPrice = calc.partialTP1Price;
         else if(inpBETriggerLevel == 2)
            triggerPrice = calc.partialTP2Price;
         else if(inpBETriggerLevel == 3)
            triggerPrice = calc.partialTP3Price;

         // Check if price has reached trigger
         if(posType == POSITION_TYPE_BUY)
            shouldMoveToBE = (SymbolInfoDouble(_Symbol, SYMBOL_BID) >= triggerPrice);
         else
            shouldMoveToBE = (SymbolInfoDouble(_Symbol, SYMBOL_ASK) <= triggerPrice);
      }

      // ===== STANDARD TP MODE =====
      if(inpAutoMoveToBE_Standard && inpTPMethod == TP_STANDARD && inpBETriggerPrice > 0)
      {
         triggerPrice = inpBETriggerPrice;

         // Check if price has reached trigger
         if(posType == POSITION_TYPE_BUY)
            shouldMoveToBE = (SymbolInfoDouble(_Symbol, SYMBOL_BID) >= triggerPrice);
         else
            shouldMoveToBE = (SymbolInfoDouble(_Symbol, SYMBOL_ASK) <= triggerPrice);
      }

      // If trigger reached, move SL to break-even
      if(shouldMoveToBE && triggerPrice > 0)
      {
         // Get actual position parameters
         double actualEntry = PositionGetDouble(POSITION_PRICE_OPEN);

         // Parse BE pips from comment (locked in at order placement)
         double actualBEPips = 0;
         int bePos = StringFind(comment, "|BE:");
         if(bePos >= 0)
         {
            // Extract BE value from comment
            string beStr = StringSubstr(comment, bePos + 4);  // Skip "|BE:"
            actualBEPips = StringToDouble(beStr);
         }
         else
         {
            // Fallback: Calculate BE for old orders (no BE in comment)
            double actualLotSize = PositionGetDouble(POSITION_VOLUME);
            actualBEPips = CalculateBEPipsForOrder(actualLotSize);
         }

         // Add user's desired offset
         double totalBEPips = actualBEPips + inpBEOffsetPips;

         // Calculate BE price based on actual entry
         double bePrice;
         if(posType == POSITION_TYPE_BUY)
            bePrice = actualEntry + (totalBEPips * g_PipValue);
         else
            bePrice = actualEntry - (totalBEPips * g_PipValue);

         double newSL = NormalizeDouble(bePrice, g_Digits);

         // Only move if current SL hasn't already been moved to or past BE
         if(posType == POSITION_TYPE_BUY)
         {
            // Only move if current SL is below the new BE level
            if(currentSL >= newSL) continue;
         }
         else // POSITION_TYPE_SELL
         {
            // Only move if current SL is above the new BE level
            if(currentSL > 0 && currentSL <= newSL) continue;
         }

         // Validate stop level distance (broker requirements)
         long stopLevel = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
         double minDistance = stopLevel * g_Point;
         double currentPrice = (posType == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         double actualDistance = (posType == POSITION_TYPE_BUY) ? (currentPrice - newSL) : (newSL - currentPrice);

         // Check if SL is far enough from current price
         if(actualDistance < minDistance)
         {
            Print("WARNING Cannot move SL to BE for Ticket #", ticket, " - too close to market (",
                  DoubleToString(actualDistance / g_Point, 0), " points, minimum: ", stopLevel, " points)");
            continue;
         }

         // Modify position SL to break-even
         if(trade.PositionModify(ticket, newSL, currentTP))
         {
            Print("OK SL moved to BE (", DoubleToString(actualBEPips, 2), " + ", DoubleToString(inpBEOffsetPips, 1), " offset = ", DoubleToString(totalBEPips, 2), " pips) for Ticket #", ticket);

            // Notifications
            if(inpBEEnableAlert)
               Alert("SL moved to BE+", DoubleToString(inpBEOffsetPips, 1), " pips for ", _Symbol, " Ticket #", ticket);

            if(inpBEEnableSound)
               PlaySound(inpBESoundFile);

            if(inpBEEnablePush)
               SendNotification("SL moved to BE for " + _Symbol + " Ticket: " + IntegerToString(ticket));
         }
         else
         {
            Print("✗ Failed to modify SL for Ticket #", ticket, " - Error: ", trade.ResultRetcodeDescription());
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   //--- Recalculate on every tick
   CalculateRisk();
   UpdatePanel();
   UpdateLines();
   DrawActualOrderLines();  // Draw entry and BE lines for placed orders
   ManageBreakEven();
}

//+------------------------------------------------------------------+
//| Timer function                                                    |
//+------------------------------------------------------------------+
void OnTimer()
{
   //--- Update display
   if(inpShowPanel)
      UpdatePanel();
}

//+------------------------------------------------------------------+
//| ChartEvent function                                              |
//+------------------------------------------------------------------+
void OnChartEvent(const int id,
                  const long &lparam,
                  const double &dparam,
                  const string &sparam)
{
   //--- Check for button clicks
   if(id == CHARTEVENT_OBJECT_CLICK)
   {
      if(sparam == g_BuyButtonName)
      {
         ExecuteBuyOrder();
         ObjectSetInteger(0, g_BuyButtonName, OBJPROP_STATE, false);
      }
      else if(sparam == g_SellButtonName)
      {
         ExecuteSellOrder();
         ObjectSetInteger(0, g_SellButtonName, OBJPROP_STATE, false);
      }
   }

   //--- Detect when lines are dragged (Dynamic mode)
   if(id == CHARTEVENT_OBJECT_DRAG)
   {
      // SL Line dragged
      if(sparam == g_SLLineName && inpSLMode == SL_DYNAMIC)
      {
         double newPrice = ObjectGetDouble(0, g_SLLineName, OBJPROP_PRICE, 0);

         // Normalize to tick size
         double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
         newPrice = NormalizeDouble(MathRound(newPrice / tickSize) * tickSize, g_Digits);

         // Update the line to normalized price
         datetime currentTime = TimeCurrent();
         datetime futureTime = currentTime + PeriodSeconds(PERIOD_CURRENT) * 100;
         ObjectMove(0, g_SLLineName, 0, currentTime, newPrice);
         ObjectMove(0, g_SLLineName, 1, futureTime, newPrice);

         // Recalculate risk with new SL
         CalculateRisk();
         UpdatePanel();

         // IMMEDIATE label update (fixes 3-second lag)
         RiskCalculation calc = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? g_ConservativeCalc : g_IdealCalc;
         double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         double slPips = MathAbs(currentPrice - calc.slPrice) / g_PipValue;
         string slLabel = "SL: " + DoubleToString(slPips, 1) + " pips";
         UpdateLabelPosition(g_SLLabelName, calc.slPrice, slLabel);

         Print("OK SL dragged to: ", DoubleToString(calc.slPrice, g_Digits), " (", DoubleToString(slPips, 1), " pips)");
      }
      // TP Line dragged
      else if(sparam == g_TPLineName && inpTPMode == TP_DYNAMIC)
      {
         double newPrice = ObjectGetDouble(0, g_TPLineName, OBJPROP_PRICE, 0);

         // Normalize to tick size
         double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
         newPrice = NormalizeDouble(MathRound(newPrice / tickSize) * tickSize, g_Digits);

         // Update the line to normalized price
         datetime currentTime = TimeCurrent();
         datetime futureTime = currentTime + PeriodSeconds(PERIOD_CURRENT) * 100;
         ObjectMove(0, g_TPLineName, 0, currentTime, newPrice);
         ObjectMove(0, g_TPLineName, 1, futureTime, newPrice);

         // Recalculate risk with new TP
         CalculateRisk();
         UpdatePanel();

         // IMMEDIATE label update (fixes 3-second lag)
         RiskCalculation calc = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? g_ConservativeCalc : g_IdealCalc;
         double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         bool isDynamicSL = (inpSLMode == SL_DYNAMIC);
         double slPips = (isDynamicSL) ? MathAbs(currentPrice - calc.slPrice) / g_PipValue : calc.slPips;
         double tpPips = MathAbs(calc.tpPrice - currentPrice) / g_PipValue;
         double rrRatio = (tpPips > 0 && slPips > 0) ? (tpPips / slPips) : 0;

         string tpLabel = "TP: " + DoubleToString(tpPips, 1) + " pips";
         if(rrRatio > 0) tpLabel += " | RR: " + DoubleToString(rrRatio, 2);
         tpLabel += " | Net: $" + DoubleToString(calc.netTP, 2);
         UpdateLabelPosition(g_TPLabelName, calc.tpPrice, tpLabel);

         Print("OK TP dragged to: ", DoubleToString(calc.tpPrice, g_Digits), " (", DoubleToString(tpPips, 1), " pips, RR: ", DoubleToString(rrRatio, 2), ")");
      }
      // Partial TP1 Line dragged
      else if(sparam == g_PartialTP1LineName && inpPartialMethod == PARTIAL_MANUAL)
      {
         double newPrice = ObjectGetDouble(0, g_PartialTP1LineName, OBJPROP_PRICE, 0);

         // Normalize to tick size
         double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
         newPrice = NormalizeDouble(MathRound(newPrice / tickSize) * tickSize, g_Digits);

         // Update the line to normalized price
         datetime currentTime = TimeCurrent();
         datetime futureTime = currentTime + PeriodSeconds(PERIOD_CURRENT) * 100;
         ObjectMove(0, g_PartialTP1LineName, 0, currentTime, newPrice);
         ObjectMove(0, g_PartialTP1LineName, 1, futureTime, newPrice);

         // Recalculate risk with new TP1
         CalculateRisk();
         UpdatePanel();

         // IMMEDIATE label update (fixes 3-second lag)
         RiskCalculation calc = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? g_ConservativeCalc : g_IdealCalc;
         bool isDynamicSL = (inpSLMode == SL_DYNAMIC);
         double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         double slPips = (isDynamicSL) ? MathAbs(currentPrice - calc.slPrice) / g_PipValue : calc.slPips;
         double rr1 = (slPips > 0) ? (calc.partialPips1 / slPips) : 0;
         string tp1Label = "TP1: " + DoubleToString(inpExitPercent1, 0) + "% @ " + DoubleToString(calc.partialPips1, 1) + " pips";
         if(rr1 > 0) tp1Label += " | RR: " + DoubleToString(rr1, 2);
         tp1Label += " | Net: $" + DoubleToString(calc.partialNetPnL1, 2);
         UpdateLabelPosition(g_PartialTP1LabelName, calc.partialTP1Price, tp1Label);

         Print("OK TP1 dragged to: ", DoubleToString(calc.partialTP1Price, g_Digits), " (", DoubleToString(calc.partialPips1, 1), " pips, RR: ", DoubleToString(rr1, 2), ")");
      }
      // Partial TP2 Line dragged
      else if(sparam == g_PartialTP2LineName && inpPartialMethod == PARTIAL_MANUAL)
      {
         double newPrice = ObjectGetDouble(0, g_PartialTP2LineName, OBJPROP_PRICE, 0);

         // Normalize to tick size
         double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
         newPrice = NormalizeDouble(MathRound(newPrice / tickSize) * tickSize, g_Digits);

         // Update the line to normalized price
         datetime currentTime = TimeCurrent();
         datetime futureTime = currentTime + PeriodSeconds(PERIOD_CURRENT) * 100;
         ObjectMove(0, g_PartialTP2LineName, 0, currentTime, newPrice);
         ObjectMove(0, g_PartialTP2LineName, 1, futureTime, newPrice);

         // Recalculate risk with new TP2
         CalculateRisk();
         UpdatePanel();

         // IMMEDIATE label update (fixes 3-second lag)
         RiskCalculation calc = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? g_ConservativeCalc : g_IdealCalc;
         bool isDynamicSL = (inpSLMode == SL_DYNAMIC);
         double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         double slPips = (isDynamicSL) ? MathAbs(currentPrice - calc.slPrice) / g_PipValue : calc.slPips;
         double rr2 = (slPips > 0) ? (calc.partialPips2 / slPips) : 0;
         string tp2Label = "TP2: " + DoubleToString(inpExitPercent2, 0) + "% @ " + DoubleToString(calc.partialPips2, 1) + " pips";
         if(rr2 > 0) tp2Label += " | RR: " + DoubleToString(rr2, 2);
         tp2Label += " | Net: $" + DoubleToString(calc.partialNetPnL2, 2);
         UpdateLabelPosition(g_PartialTP2LabelName, calc.partialTP2Price, tp2Label);

         Print("OK TP2 dragged to: ", DoubleToString(calc.partialTP2Price, g_Digits), " (", DoubleToString(calc.partialPips2, 1), " pips, RR: ", DoubleToString(rr2, 2), ")");
      }
      // Partial TP3 Line dragged
      else if(sparam == g_PartialTP3LineName && inpPartialMethod == PARTIAL_MANUAL && inpNumberOfLevels == 3)
      {
         double newPrice = ObjectGetDouble(0, g_PartialTP3LineName, OBJPROP_PRICE, 0);

         // Normalize to tick size
         double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
         newPrice = NormalizeDouble(MathRound(newPrice / tickSize) * tickSize, g_Digits);

         // Update the line to normalized price
         datetime currentTime = TimeCurrent();
         datetime futureTime = currentTime + PeriodSeconds(PERIOD_CURRENT) * 100;
         ObjectMove(0, g_PartialTP3LineName, 0, currentTime, newPrice);
         ObjectMove(0, g_PartialTP3LineName, 1, futureTime, newPrice);

         // Recalculate risk with new TP3
         CalculateRisk();
         UpdatePanel();

         // IMMEDIATE label update (fixes 3-second lag)
         RiskCalculation calc = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? g_ConservativeCalc : g_IdealCalc;
         bool isDynamicSL = (inpSLMode == SL_DYNAMIC);
         double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         double slPips = (isDynamicSL) ? MathAbs(currentPrice - calc.slPrice) / g_PipValue : calc.slPips;
         double exitPercent3 = 100 - inpExitPercent1 - inpExitPercent2;
         double rr3 = (slPips > 0) ? (calc.partialPips3 / slPips) : 0;
         string tp3Label = "TP3: " + DoubleToString(exitPercent3, 0) + "% @ " + DoubleToString(calc.partialPips3, 1) + " pips";
         if(rr3 > 0) tp3Label += " | RR: " + DoubleToString(rr3, 2);
         tp3Label += " | Net: $" + DoubleToString(calc.partialNetPnL3, 2);
         UpdateLabelPosition(g_PartialTP3LabelName, calc.partialTP3Price, tp3Label);

         Print("OK TP3 dragged to: ", DoubleToString(calc.partialTP3Price, g_Digits), " (", DoubleToString(calc.partialPips3, 1), " pips, RR: ", DoubleToString(rr3, 2), ")");
      }
   }
}

//+------------------------------------------------------------------+
//| Calculate Risk and Lot Sizes                                     |
//+------------------------------------------------------------------+
void CalculateRisk()
{
   double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   
   //--- Determine SL distance in pips
   double slPips = 0;
   double slPrice = 0;
   bool isLongTrade = true;  // Determine trade direction
   
   if(inpSLMode == SL_MANUAL)
   {
      slPips = inpManualSLPips;
      isLongTrade = (inpTradeDirection == TRADE_BUY);

      if(isLongTrade)
         slPrice = currentPrice - (slPips * g_PipValue);
      else
         slPrice = currentPrice + (slPips * g_PipValue);
   }
   else // SL_DYNAMIC
   {
      // Read price from draggable line if it exists, otherwise use manual SL pips as default
      if(ObjectFind(0, g_SLLineName) >= 0)
      {
         slPrice = ObjectGetDouble(0, g_SLLineName, OBJPROP_PRICE, 0);
         slPips = MathAbs(currentPrice - slPrice) / g_PipValue;
         // Determine direction: if SL is below current price = LONG, if above = SHORT
         isLongTrade = (slPrice < currentPrice);
      }
      else
      {
         // Default: use manual SL pips distance (line will be created and user can drag it)
         slPips = inpManualSLPips;
         slPrice = currentPrice - (slPips * g_PipValue);
         isLongTrade = true;
      }
   }
   
   //--- IDEAL CALCULATION (No Entry Slippage)
   double idealTotalPips = slPips + inpExitSlippage;
   double riskAmount = inpAccountSize * (inpRiskPercent / 100.0);
   
   // Calculate pip value in USD for the lot size calculation
   double pipValuePerLot = (inpPipValueMode == PIP_MANUAL) ? inpManualPipValue : (g_PointValue * (g_PipValue / g_Point));
   
   g_IdealCalc.baseSLPips = slPips;  // Store base SL
   g_IdealCalc.slPips = slPips;
   g_IdealCalc.lotSize = riskAmount / ((idealTotalPips * pipValuePerLot) + inpCommissionPerLot);
   g_IdealCalc.commission = g_IdealCalc.lotSize * inpCommissionPerLot;
   g_IdealCalc.priceRisk = g_IdealCalc.lotSize * idealTotalPips * pipValuePerLot;
   g_IdealCalc.totalRisk = g_IdealCalc.priceRisk + g_IdealCalc.commission;
   g_IdealCalc.riskPercent = (g_IdealCalc.totalRisk / inpAccountSize) * 100.0;
   g_IdealCalc.entryPrice = currentPrice;
   g_IdealCalc.slPrice = slPrice;
   
   // Break-even calculation
   double idealTotalFees = g_IdealCalc.commission + (g_IdealCalc.lotSize * inpExitSlippage * pipValuePerLot);
   g_IdealCalc.breakEvenPips = idealTotalFees / (g_IdealCalc.lotSize * pipValuePerLot);
   
   // Take Profit calculation
   double idealCommissionPips = g_IdealCalc.commission / (g_IdealCalc.lotSize * pipValuePerLot);
   double idealTotalRiskPips = slPips + inpExitSlippage + idealCommissionPips;
   
   if(inpTPMode == TP_RR_MULTIPLE)
   {
      g_IdealCalc.tpPips = idealTotalRiskPips * inpRRMultiple;
      g_IdealCalc.tpPrice = isLongTrade ? (currentPrice + (g_IdealCalc.tpPips * g_PipValue)) : (currentPrice - (g_IdealCalc.tpPips * g_PipValue));
   }
   else // TP_DYNAMIC
   {
      // Read price from draggable line if it exists, otherwise use RR multiple as default
      if(ObjectFind(0, g_TPLineName) >= 0)
      {
         g_IdealCalc.tpPrice = ObjectGetDouble(0, g_TPLineName, OBJPROP_PRICE, 0);
         g_IdealCalc.tpPips = MathAbs(g_IdealCalc.tpPrice - currentPrice) / g_PipValue;
      }
      else
      {
         // Default: use RR multiple (line will be created and user can drag it)
         g_IdealCalc.tpPips = idealTotalRiskPips * inpRRMultiple;
         g_IdealCalc.tpPrice = isLongTrade ? (currentPrice + (g_IdealCalc.tpPips * g_PipValue)) : (currentPrice - (g_IdealCalc.tpPips * g_PipValue));
      }
   }
   g_IdealCalc.grossTP = g_IdealCalc.lotSize * g_IdealCalc.tpPips * pipValuePerLot;
   double idealExitSlippageCost = g_IdealCalc.lotSize * inpExitSlippage * pipValuePerLot;
   g_IdealCalc.netTP = g_IdealCalc.grossTP - idealExitSlippageCost - g_IdealCalc.commission;
   
   // Margin calculation
   double idealContractValue = g_IdealCalc.lotSize * 100000;
   double idealNotionalUSD = idealContractValue * currentPrice;
   g_IdealCalc.marginRequired = idealNotionalUSD * (inpMarginPercent / 100.0);
   g_IdealCalc.buyingPowerPercent = (g_IdealCalc.marginRequired / inpAccountSize) * 100.0;
   g_IdealCalc.returnOnMargin = g_IdealCalc.marginRequired > 0 ? (g_IdealCalc.netTP / g_IdealCalc.marginRequired) * 100.0 : 0;
   
   //--- CONSERVATIVE CALCULATION (With Entry Slippage)
   double effectiveSL = slPips + inpEntrySlippage;
   double conservativeTotalPips = effectiveSL + inpExitSlippage;
   
   g_ConservativeCalc.baseSLPips = slPips;  // Store base SL
   g_ConservativeCalc.slPips = effectiveSL;
   g_ConservativeCalc.lotSize = riskAmount / ((conservativeTotalPips * pipValuePerLot) + inpCommissionPerLot);
   g_ConservativeCalc.commission = g_ConservativeCalc.lotSize * inpCommissionPerLot;
   g_ConservativeCalc.priceRisk = g_ConservativeCalc.lotSize * conservativeTotalPips * pipValuePerLot;
   g_ConservativeCalc.totalRisk = g_ConservativeCalc.priceRisk + g_ConservativeCalc.commission;
   g_ConservativeCalc.riskPercent = (g_ConservativeCalc.totalRisk / inpAccountSize) * 100.0;
   // Entry price accounting for slippage based on direction
   g_ConservativeCalc.entryPrice = isLongTrade ? (currentPrice + (inpEntrySlippage * g_PipValue)) : (currentPrice - (inpEntrySlippage * g_PipValue));
   g_ConservativeCalc.slPrice = slPrice;
   
   // Break-even calculation
   double conservativeTotalFees = g_ConservativeCalc.commission + (g_ConservativeCalc.lotSize * inpExitSlippage * pipValuePerLot);
   g_ConservativeCalc.breakEvenPips = conservativeTotalFees / (g_ConservativeCalc.lotSize * pipValuePerLot);
   
   // Take Profit calculation
   double conservativeCommissionPips = g_ConservativeCalc.commission / (g_ConservativeCalc.lotSize * pipValuePerLot);
   double conservativeTotalRiskPips = effectiveSL + inpExitSlippage + conservativeCommissionPips;
   
   if(inpTPMode == TP_RR_MULTIPLE)
   {
      g_ConservativeCalc.tpPips = conservativeTotalRiskPips * inpRRMultiple;
      g_ConservativeCalc.tpPrice = isLongTrade ? (g_ConservativeCalc.entryPrice + (g_ConservativeCalc.tpPips * g_PipValue)) : (g_ConservativeCalc.entryPrice - (g_ConservativeCalc.tpPips * g_PipValue));
   }
   else // TP_DYNAMIC
   {
      // Read price from draggable line if it exists, otherwise use RR multiple as default
      if(ObjectFind(0, g_TPLineName) >= 0)
      {
         g_ConservativeCalc.tpPrice = ObjectGetDouble(0, g_TPLineName, OBJPROP_PRICE, 0);
         g_ConservativeCalc.tpPips = MathAbs(g_ConservativeCalc.tpPrice - g_ConservativeCalc.entryPrice) / g_PipValue;
      }
      else
      {
         // Default: use RR multiple (line will be created and user can drag it)
         g_ConservativeCalc.tpPips = conservativeTotalRiskPips * inpRRMultiple;
         g_ConservativeCalc.tpPrice = isLongTrade ? (g_ConservativeCalc.entryPrice + (g_ConservativeCalc.tpPips * g_PipValue)) : (g_ConservativeCalc.entryPrice - (g_ConservativeCalc.tpPips * g_PipValue));
      }
   }
   g_ConservativeCalc.grossTP = g_ConservativeCalc.lotSize * g_ConservativeCalc.tpPips * pipValuePerLot;
   double conservativeExitSlippageCost = g_ConservativeCalc.lotSize * inpExitSlippage * pipValuePerLot;
   g_ConservativeCalc.netTP = g_ConservativeCalc.grossTP - conservativeExitSlippageCost - g_ConservativeCalc.commission;
   
   // Margin calculation
   double conservativeContractValue = g_ConservativeCalc.lotSize * 100000;
   double conservativeNotionalUSD = conservativeContractValue * currentPrice;
   g_ConservativeCalc.marginRequired = conservativeNotionalUSD * (inpMarginPercent / 100.0);
   g_ConservativeCalc.buyingPowerPercent = (g_ConservativeCalc.marginRequired / inpAccountSize) * 100.0;
   g_ConservativeCalc.returnOnMargin = g_ConservativeCalc.marginRequired > 0 ? (g_ConservativeCalc.netTP / g_ConservativeCalc.marginRequired) * 100.0 : 0;
   
   //--- PARTIAL EXITS CALCULATION
   if(inpTPMethod == TP_PARTIAL_EXITS)
   {
      CalculatePartialExits(g_IdealCalc, pipValuePerLot, isLongTrade);
      CalculatePartialExits(g_ConservativeCalc, pipValuePerLot, isLongTrade);
   }
}

//+------------------------------------------------------------------+
//| Create Information Panel                                          |
//+------------------------------------------------------------------+
void CreatePanel()
{
   if(!inpShowPanel) return;

   int x = inpPanelX;
   int y = inpPanelY;
   int width = 280;
   int rowHeight = 20;

   // Calculate dynamic panel height based on TP method
   int panelHeight;
   if(inpTPMethod == TP_PARTIAL_EXITS)
   {
      if(inpNumberOfLevels == 3)
         panelHeight = 600;  // Partial Exits with 3 levels
      else
         panelHeight = 560;  // Partial Exits with 2 levels
   }
   else
   {
      panelHeight = 480;  // Standard TP mode
   }

   // Create background rectangle - use solid color, no transparency for RECTANGLE_LABEL
   ObjectCreate(0, g_PanelName, OBJ_RECTANGLE_LABEL, 0, 0, 0);
   ObjectSetInteger(0, g_PanelName, OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, g_PanelName, OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, g_PanelName, OBJPROP_XSIZE, width);
   ObjectSetInteger(0, g_PanelName, OBJPROP_YSIZE, panelHeight);
   ObjectSetInteger(0, g_PanelName, OBJPROP_BGCOLOR, inpPanelBgColor);
   ObjectSetInteger(0, g_PanelName, OBJPROP_BORDER_TYPE, BORDER_FLAT);
   ObjectSetInteger(0, g_PanelName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
   ObjectSetInteger(0, g_PanelName, OBJPROP_COLOR, clrBlack);
   ObjectSetInteger(0, g_PanelName, OBJPROP_STYLE, STYLE_SOLID);
   ObjectSetInteger(0, g_PanelName, OBJPROP_WIDTH, 1);
   ObjectSetInteger(0, g_PanelName, OBJPROP_BACK, false);  // Changed to false so it's on top
   ObjectSetInteger(0, g_PanelName, OBJPROP_SELECTABLE, false);
   ObjectSetInteger(0, g_PanelName, OBJPROP_SELECTED, false);
   ObjectSetInteger(0, g_PanelName, OBJPROP_HIDDEN, true);
}

//+------------------------------------------------------------------+
//| Update Information Panel                                          |
//+------------------------------------------------------------------+
void UpdatePanel()
{
   if(!inpShowPanel) return;
   
   int x = inpPanelX + 10;
   int y = inpPanelY + 10;
   int rowHeight = 18;
   int currentRow = 0;
   
   // Get the display calculation based on mode
   RiskCalculation display = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? g_ConservativeCalc : g_IdealCalc;
   RiskCalculation alternate = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? g_IdealCalc : g_ConservativeCalc;
   string modeLabel = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? " (Conservative)" : " (Ideal)";
   string altModeLabel = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? " (Ideal)" : " (Conservative)";
   
   // Title
   CreateLabel("PanelTitle", "RISK CALCULATOR", x + 60, y + (currentRow * rowHeight), clrDodgerBlue, 10, "Arial Bold");
   currentRow++;
   
   CreateLabel("PanelMode", modeLabel, x + 90, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   currentRow += 2;
   
   // Lot Size
   CreateLabel("LotSizeLabel", "Lot Size:", x, y + (currentRow * rowHeight), inpPanelTextColor, 9, "Arial Bold");
   color lotColor = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? clrOrangeRed : clrDodgerBlue;
   CreateLabel("LotSizeValue", DoubleToString(display.lotSize, 2), x + 180, y + (currentRow * rowHeight), lotColor, 9, "Arial Bold");
   currentRow++;
   
   if(inpShowAlternateLotSize)
   {
      CreateLabel("AltLotSizeLabel", "Lot Size" + altModeLabel + ":", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
      color altColor = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? clrDodgerBlue : clrOrangeRed;
      CreateLabel("AltLotSizeValue", DoubleToString(alternate.lotSize, 2), x + 180, y + (currentRow * rowHeight), altColor, 8, "Arial");
      currentRow++;
   }
   
   // Pip Value Display
   if(inpShowPipValue)
   {
      double pipValuePerLot = (inpPipValueMode == PIP_MANUAL) ? inpManualPipValue : (g_PointValue * (g_PipValue / g_Point));
      string pipValueLabel = (inpPipValueMode == PIP_MANUAL) ? "Pip Value (Manual):" : "Pip Value (Auto):";
      CreateLabel("PipValueLabel", pipValueLabel, x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
      CreateLabel("PipValueValue", "$" + DoubleToString(pipValuePerLot, 2), x + 180, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
      currentRow++;
   }
   
   currentRow++;
   CreateLabel("Divider1", "─────────────────────────────", x, y + (currentRow * rowHeight), clrGray, 8, "Arial");
   currentRow++;
   
   // Stop Loss Structure
   string slModeText = (inpSLMode == SL_MANUAL) ? "Base SL:" : "Base SL (Dynamic):";
   CreateLabel("SLLabel", slModeText, x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   CreateLabel("SLValue", DoubleToString(display.baseSLPips, 1) + " pips", x + 180, y + (currentRow * rowHeight), clrRed, 8, "Arial");
   currentRow++;
   
   double totalRiskPips = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? (display.slPips + inpExitSlippage) : (display.slPips + inpExitSlippage);
   CreateLabel("TotalRiskPipsLabel", "Total Risk Distance:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   CreateLabel("TotalRiskPipsValue", DoubleToString(totalRiskPips, 1) + " pips", x + 180, y + (currentRow * rowHeight), clrRed, 8, "Arial");
   currentRow++;
   
   // Take Profit Display
   if(inpShowTP)
   {
      if(inpTPMethod == TP_PARTIAL_EXITS)
      {
         // Show partial exits summary
         double exitPercent3 = (inpNumberOfLevels == 3) ? (100 - inpExitPercent1 - inpExitPercent2) : 0;
         string partialMethodLabel = (inpPartialMethod == PARTIAL_RR) ? " (RR)" : " (Manual)";
         
         CreateLabel("TPLabel", "Partial Exits" + partialMethodLabel + ":", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
         CreateLabel("TPValue", IntegerToString(inpNumberOfLevels) + " Levels", x + 180, y + (currentRow * rowHeight), clrGreen, 8, "Arial");
         currentRow++;
      }
      else
      {
         string tpModeText = (inpTPMode == TP_RR_MULTIPLE) ? "Take Profit (RR: " + DoubleToString(inpRRMultiple, 1) + "):" : "Take Profit (Dynamic):";
         CreateLabel("TPLabel", tpModeText, x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
         CreateLabel("TPValue", DoubleToString(display.tpPips, 1) + " pips", x + 180, y + (currentRow * rowHeight), clrGreen, 8, "Arial");
         currentRow++;
      }
   }
   
   CreateLabel("BELabel", "Break-even:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   CreateLabel("BEValue", DoubleToString(display.breakEvenPips, 2) + " pips", x + 180, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   currentRow++;
   
   currentRow++;
   CreateLabel("Divider2", "─────────────────────────────", x, y + (currentRow * rowHeight), clrGray, 8, "Arial");
   currentRow++;
   
   // Risk Breakdown
   CreateLabel("PriceRiskLabel", "Price Risk:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   CreateLabel("PriceRiskValue", "$" + DoubleToString(display.priceRisk, 2), x + 180, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   currentRow++;
   
   CreateLabel("CommLabel", "Commission:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   CreateLabel("CommValue", "$" + DoubleToString(display.commission, 2), x + 180, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   currentRow++;
   
   CreateLabel("TotalRiskLabel", "Total Risk:", x, y + (currentRow * rowHeight), inpPanelTextColor, 9, "Arial Bold");
   CreateLabel("TotalRiskValue", "$" + DoubleToString(display.totalRisk, 2), x + 180, y + (currentRow * rowHeight), clrRed, 9, "Arial Bold");
   currentRow++;
   
   CreateLabel("RiskPercentLabel", "Actual Risk %:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   CreateLabel("RiskPercentValue", DoubleToString(display.riskPercent, 2) + "%", x + 180, y + (currentRow * rowHeight), clrRed, 8, "Arial");
   currentRow++;
   
   if(inpShowTP)
   {
      if(inpTPMethod == TP_PARTIAL_EXITS)
      {
         // Show partial exits details
         double exitPercent3 = (inpNumberOfLevels == 3) ? (100 - inpExitPercent1 - inpExitPercent2) : 0;
         
         CreateLabel("PartialTitle", "Partial Exits Breakdown:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial Bold");
         currentRow++;
         
         // Level 1 - condensed
         CreateLabel("Level1Label", "L1: " + DoubleToString(inpExitPercent1, 0) + "% (" + DoubleToString(display.partialLots1, 2) + " lots)", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
         currentRow++;
         CreateLabel("Level1Pips", "  +" + DoubleToString(display.partialPips1, 1) + " pips", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
         CreateLabel("Level1Net", "$" + DoubleToString(display.partialNetPnL1, 2), x + 180, y + (currentRow * rowHeight), clrGreen, 8, "Arial");
         currentRow++;
         
         // Level 2 - condensed
         CreateLabel("Level2Label", "L2: " + DoubleToString(inpExitPercent2, 0) + "% (" + DoubleToString(display.partialLots2, 2) + " lots)", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
         currentRow++;
         CreateLabel("Level2Pips", "  +" + DoubleToString(display.partialPips2, 1) + " pips", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
         CreateLabel("Level2Net", "$" + DoubleToString(display.partialNetPnL2, 2), x + 180, y + (currentRow * rowHeight), clrGreen, 8, "Arial");
         currentRow++;
         
         // Level 3 (if enabled) - condensed
         if(inpNumberOfLevels == 3)
         {
            CreateLabel("Level3Label", "L3: " + DoubleToString(exitPercent3, 0) + "% (" + DoubleToString(display.partialLots3, 2) + " lots)", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
            currentRow++;
            CreateLabel("Level3Pips", "  +" + DoubleToString(display.partialPips3, 1) + " pips", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
            CreateLabel("Level3Net", "$" + DoubleToString(display.partialNetPnL3, 2), x + 180, y + (currentRow * rowHeight), clrGreen, 8, "Arial");
            currentRow++;
         }
         
         CreateLabel("PartialTotalLabel", "Total Net P&L:", x, y + (currentRow * rowHeight), inpPanelTextColor, 9, "Arial Bold");
         CreateLabel("PartialTotalValue", "$" + DoubleToString(display.partialTotalNetPnL, 2), x + 180, y + (currentRow * rowHeight), clrGreen, 9, "Arial Bold");
         currentRow++;
      }
      else
      {
         CreateLabel("NetTPLabel", "Net Take Profit:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
         CreateLabel("NetTPValue", "$" + DoubleToString(display.netTP, 2), x + 180, y + (currentRow * rowHeight), clrGreen, 8, "Arial");
         currentRow++;
      }
   }
   
   currentRow++;
   CreateLabel("Divider3", "─────────────────────────────", x, y + (currentRow * rowHeight), clrGray, 8, "Arial");
   currentRow++;
   
   // Margin Info
   CreateLabel("MarginLabel", "Margin Required:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   CreateLabel("MarginValue", "$" + DoubleToString(display.marginRequired, 2), x + 180, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   currentRow++;
   
   CreateLabel("BuyingPowerLabel", "Buying Power:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   CreateLabel("BuyingPowerValue", DoubleToString(display.buyingPowerPercent, 2) + "%", x + 180, y + (currentRow * rowHeight), clrGreen, 8, "Arial");
   currentRow++;
   
   if(inpShowReturnOnMargin)
   {
      CreateLabel("ROMLabel", "Return on Margin:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
      color romColor = (display.returnOnMargin > 0) ? clrGreen : clrRed;
      CreateLabel("ROMValue", DoubleToString(display.returnOnMargin, 2) + "%", x + 180, y + (currentRow * rowHeight), romColor, 8, "Arial");
      currentRow++;
   }
   
   ChartRedraw(0);
}

//+------------------------------------------------------------------+
//| Create Label Helper                                              |
//+------------------------------------------------------------------+
void CreateLabel(string name, string text, int x, int y, color clr, int fontSize = 8, string font = "Arial")
{
   string objName = g_PanelName + "_" + name;
   
   if(ObjectFind(0, objName) < 0)
   {
      ObjectCreate(0, objName, OBJ_LABEL, 0, 0, 0);
      ObjectSetInteger(0, objName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, objName, OBJPROP_ANCHOR, ANCHOR_LEFT_UPPER);
      ObjectSetInteger(0, objName, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(0, objName, OBJPROP_HIDDEN, true);
   }
   
   ObjectSetInteger(0, objName, OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, objName, OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, objName, OBJPROP_COLOR, clr);
   ObjectSetInteger(0, objName, OBJPROP_FONTSIZE, fontSize);
   ObjectSetString(0, objName, OBJPROP_FONT, font);
   ObjectSetString(0, objName, OBJPROP_TEXT, text);
}

//+------------------------------------------------------------------+
//| Delete Panel                                                      |
//+------------------------------------------------------------------+
void DeletePanel()
{
   ObjectsDeleteAll(0, g_PanelName);
}

//+------------------------------------------------------------------+
//| Create Buy/Sell Buttons                                          |
//+------------------------------------------------------------------+
void CreateButtons()
{
   // Calculate dynamic panel height based on TP method
   int panelHeight;
   if(inpTPMethod == TP_PARTIAL_EXITS)
   {
      if(inpNumberOfLevels == 3)
         panelHeight = 600;  // Partial Exits with 3 levels
      else
         panelHeight = 560;  // Partial Exits with 2 levels
   }
   else
   {
      panelHeight = 480;  // Standard TP mode
   }

   int buttonY = inpPanelY + panelHeight + 10;  // Position buttons 10px below panel
   
   // Buy Button
   ObjectCreate(0, g_BuyButtonName, OBJ_BUTTON, 0, 0, 0);
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_XDISTANCE, inpPanelX);
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_YDISTANCE, buttonY);
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_XSIZE, inpButtonWidth);
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_YSIZE, inpButtonHeight);
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_BGCOLOR, inpBuyButtonColor);
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_COLOR, clrWhite);
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_FONTSIZE, 10);
   ObjectSetString(0, g_BuyButtonName, OBJPROP_FONT, "Arial Bold");
   ObjectSetString(0, g_BuyButtonName, OBJPROP_TEXT, "BUY");
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_SELECTABLE, false);
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_HIDDEN, true);
   
   // Sell Button
   ObjectCreate(0, g_SellButtonName, OBJ_BUTTON, 0, 0, 0);
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_XDISTANCE, inpPanelX + inpButtonWidth + 10);
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_YDISTANCE, buttonY);
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_XSIZE, inpButtonWidth);
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_YSIZE, inpButtonHeight);
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_BGCOLOR, inpSellButtonColor);
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_COLOR, clrWhite);
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_FONTSIZE, 10);
   ObjectSetString(0, g_SellButtonName, OBJPROP_FONT, "Arial Bold");
   ObjectSetString(0, g_SellButtonName, OBJPROP_TEXT, "SELL");
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_SELECTABLE, false);
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_HIDDEN, true);
}

//+------------------------------------------------------------------+
//| Delete Buttons                                                    |
//+------------------------------------------------------------------+
void DeleteButtons()
{
   ObjectDelete(0, g_BuyButtonName);
   ObjectDelete(0, g_SellButtonName);
}

//+------------------------------------------------------------------+
//| Calculate Partial Exits                                          |
//+------------------------------------------------------------------+
void CalculatePartialExits(RiskCalculation &calc, double pipValuePerLot, bool isLongTrade)
{
   // Calculate exit percentages
   double exitPercent3 = (inpNumberOfLevels == 3) ? (100 - inpExitPercent1 - inpExitPercent2) : 0;
   if(exitPercent3 < 0) exitPercent3 = 0;
   
   // Calculate lot sizes for each level
   calc.partialLots1 = calc.lotSize * (inpExitPercent1 / 100.0);
   calc.partialLots2 = calc.lotSize * (inpExitPercent2 / 100.0);
   calc.partialLots3 = (inpNumberOfLevels == 3) ? calc.lotSize * (exitPercent3 / 100.0) : 0;
   
   if(inpPartialMethod == PARTIAL_RR)
   {
      // RR Multiples Method
      // Level 1: Exit X% to NET inpRRTarget1 * total risk
      double targetNet1 = calc.totalRisk * inpRRTarget1;
      double feesExit1 = (calc.partialLots1 * inpCommissionPerLot) + (calc.partialLots1 * inpExitSlippage * pipValuePerLot);
      double grossNeeded1 = targetNet1 + feesExit1;
      calc.partialPips1 = grossNeeded1 / (calc.partialLots1 * pipValuePerLot);
      calc.partialNetPnL1 = targetNet1;
      
      if(inpNumberOfLevels == 2)
      {
         // Level 2: Remaining % reaches overall target
         double overallTarget2 = calc.totalRisk * inpRRTarget2Overall;
         double stillNeeded2 = overallTarget2 - targetNet1;
         double feesExit2 = (calc.partialLots2 * inpCommissionPerLot) + (calc.partialLots2 * inpExitSlippage * pipValuePerLot);
         double grossNeeded2 = stillNeeded2 + feesExit2;
         calc.partialPips2 = grossNeeded2 / (calc.partialLots2 * pipValuePerLot);
         calc.partialNetPnL2 = stillNeeded2;
         
         calc.partialTotalNetPnL = calc.partialNetPnL1 + calc.partialNetPnL2;
      }
      else
      {
         // Level 2: Reach intermediate target
         double overallTarget2 = calc.totalRisk * inpRRTarget2Overall;
         double stillNeeded2 = overallTarget2 - targetNet1;
         double feesExit2 = (calc.partialLots2 * inpCommissionPerLot) + (calc.partialLots2 * inpExitSlippage * pipValuePerLot);
         double grossNeeded2 = stillNeeded2 + feesExit2;
         calc.partialPips2 = grossNeeded2 / (calc.partialLots2 * pipValuePerLot);
         calc.partialNetPnL2 = stillNeeded2;
         
         // Level 3: Reach final target
         double overallTarget3 = calc.totalRisk * inpRRTarget3Overall;
         double stillNeeded3 = overallTarget3 - overallTarget2;
         double feesExit3 = (calc.partialLots3 * inpCommissionPerLot) + (calc.partialLots3 * inpExitSlippage * pipValuePerLot);
         double grossNeeded3 = stillNeeded3 + feesExit3;
         calc.partialPips3 = grossNeeded3 / (calc.partialLots3 * pipValuePerLot);
         calc.partialNetPnL3 = stillNeeded3;
         
         calc.partialTotalNetPnL = calc.partialNetPnL1 + calc.partialNetPnL2 + calc.partialNetPnL3;
      }
      
      // Convert to price levels
      if(isLongTrade)
      {
         calc.partialTP1Price = calc.entryPrice + (calc.partialPips1 * g_PipValue);
         calc.partialTP2Price = calc.entryPrice + (calc.partialPips2 * g_PipValue);
         calc.partialTP3Price = (inpNumberOfLevels == 3) ? calc.entryPrice + (calc.partialPips3 * g_PipValue) : 0;
      }
      else
      {
         calc.partialTP1Price = calc.entryPrice - (calc.partialPips1 * g_PipValue);
         calc.partialTP2Price = calc.entryPrice - (calc.partialPips2 * g_PipValue);
         calc.partialTP3Price = (inpNumberOfLevels == 3) ? calc.entryPrice - (calc.partialPips3 * g_PipValue) : 0;
      }
   }
   else // PARTIAL_MANUAL
   {
      // Manual Levels - Read from draggable lines if they exist, otherwise use RR multiples as default
      if(ObjectFind(0, g_PartialTP1LineName) >= 0)
      {
         calc.partialTP1Price = ObjectGetDouble(0, g_PartialTP1LineName, OBJPROP_PRICE, 0);
      }
      else
      {
         // Default: use RR multiple (line will be created and user can drag it)
         double rr1Pips = calc.slPips * inpRRTarget1;
         calc.partialTP1Price = isLongTrade ? (calc.entryPrice + (rr1Pips * g_PipValue)) : (calc.entryPrice - (rr1Pips * g_PipValue));
      }

      if(ObjectFind(0, g_PartialTP2LineName) >= 0)
      {
         calc.partialTP2Price = ObjectGetDouble(0, g_PartialTP2LineName, OBJPROP_PRICE, 0);
      }
      else
      {
         // Default: use RR multiple
         double rr2Pips = calc.slPips * inpRRTarget2Overall;
         calc.partialTP2Price = isLongTrade ? (calc.entryPrice + (rr2Pips * g_PipValue)) : (calc.entryPrice - (rr2Pips * g_PipValue));
      }

      if(inpNumberOfLevels == 3)
      {
         if(ObjectFind(0, g_PartialTP3LineName) >= 0)
         {
            calc.partialTP3Price = ObjectGetDouble(0, g_PartialTP3LineName, OBJPROP_PRICE, 0);
         }
         else
         {
            // Default: use RR multiple
            double rr3Pips = calc.slPips * inpRRTarget3Overall;
            calc.partialTP3Price = isLongTrade ? (calc.entryPrice + (rr3Pips * g_PipValue)) : (calc.entryPrice - (rr3Pips * g_PipValue));
         }
      }
      else
      {
         calc.partialTP3Price = 0;
      }
      
      // Calculate pips from manual prices
      if(isLongTrade)
      {
         calc.partialPips1 = (calc.partialTP1Price - calc.entryPrice) / g_PipValue;
         calc.partialPips2 = (calc.partialTP2Price - calc.entryPrice) / g_PipValue;
         calc.partialPips3 = (inpNumberOfLevels == 3) ? (calc.partialTP3Price - calc.entryPrice) / g_PipValue : 0;
      }
      else
      {
         calc.partialPips1 = (calc.entryPrice - calc.partialTP1Price) / g_PipValue;
         calc.partialPips2 = (calc.entryPrice - calc.partialTP2Price) / g_PipValue;
         calc.partialPips3 = (inpNumberOfLevels == 3) ? (calc.entryPrice - calc.partialTP3Price) / g_PipValue : 0;
      }
      
      // Calculate P&L for manual levels
      double totalFees = (calc.lotSize * inpCommissionPerLot) + (calc.lotSize * inpExitSlippage * pipValuePerLot);
      double partialFees1 = totalFees * (inpExitPercent1 / 100.0);
      double partialFees2 = totalFees * (inpExitPercent2 / 100.0);
      double partialFees3 = (inpNumberOfLevels == 3) ? totalFees * (exitPercent3 / 100.0) : 0;
      
      double partialGrossPnL1 = calc.partialLots1 * calc.partialPips1 * pipValuePerLot;
      double partialGrossPnL2 = calc.partialLots2 * calc.partialPips2 * pipValuePerLot;
      double partialGrossPnL3 = (inpNumberOfLevels == 3) ? calc.partialLots3 * calc.partialPips3 * pipValuePerLot : 0;
      
      calc.partialNetPnL1 = partialGrossPnL1 - partialFees1;
      calc.partialNetPnL2 = partialGrossPnL2 - partialFees2;
      calc.partialNetPnL3 = (inpNumberOfLevels == 3) ? partialGrossPnL3 - partialFees3 : 0;
      
      calc.partialTotalNetPnL = (inpNumberOfLevels == 3) ? 
         (calc.partialNetPnL1 + calc.partialNetPnL2 + calc.partialNetPnL3) : 
         (calc.partialNetPnL1 + calc.partialNetPnL2);
   }
}

//+------------------------------------------------------------------+
//| Calculate Break-Even Pips at Order Placement                     |
//+------------------------------------------------------------------+
double CalculateBEPipsForOrder(double lotSize)
{
   // Calculate actual commission for this position
   double actualCommission = lotSize * inpCommissionPerLot;

   // Calculate pip value
   double pipValuePerLot = (inpPipValueMode == PIP_MANUAL) ? inpManualPipValue : (g_PointValue * (g_PipValue / g_Point));

   // Calculate actual exit slippage cost
   double actualExitSlippageCost = lotSize * inpExitSlippage * pipValuePerLot;

   // Calculate total fees
   double actualTotalFees = actualCommission + actualExitSlippageCost;

   // Calculate actual BE distance in pips
   double actualBEPips = actualTotalFees / (lotSize * pipValuePerLot);

   return actualBEPips;
}

//+------------------------------------------------------------------+
//| Execute Buy Order                                                 |
//+------------------------------------------------------------------+
void ExecuteBuyOrder()
{
   RiskCalculation calc = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? g_ConservativeCalc : g_IdealCalc;

   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double sl = NormalizeDouble(calc.slPrice, g_Digits);
   double lots = NormalizeDouble(calc.lotSize, 2);

   // Validate lot size
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);

   if(lots < minLot) lots = minLot;
   if(lots > maxLot) lots = maxLot;
   lots = MathFloor(lots / lotStep) * lotStep;

   trade.SetExpertMagicNumber(123456);
   trade.SetDeviationInPoints(10);

   // Calculate and lock in BE pips at order placement
   double bePips = CalculateBEPipsForOrder(lots);
   string baseComment = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? "RM_Buy_CONS" : "RM_Buy_IDEAL";
   string commentWithBE = baseComment + "|BE:" + DoubleToString(bePips, 2);

   bool result = false;
   double tp = 0;

   // Determine TP based on inpPlaceSLTP setting
   if(inpPlaceSLTP)
   {
      if(inpTPMethod == TP_STANDARD)
      {
         // Standard TP: Place order with SL and TP
         tp = inpShowTP ? NormalizeDouble(calc.tpPrice, g_Digits) : 0;
         result = trade.Buy(lots, _Symbol, ask, sl, tp, commentWithBE);

         if(result)
         {
            Print("BUY Order Executed: Lot Size = ", lots, ", SL = ", sl, ", TP = ", tp);
            Comment("OK BUY Order Placed Successfully!\nLot Size: ", lots, "\nSL: ", sl, "\nTP: ", tp);
         }
         else
         {
            Print("BUY Order Failed: ", trade.ResultRetcodeDescription());
            Comment("✗ BUY Order Failed: ", trade.ResultRetcodeDescription());
         }
      }
      else // TP_PARTIAL_EXITS
      {
         // Partial Exits: Place main order with SL only, then place limit orders for each level
         result = trade.Buy(lots, _Symbol, ask, sl, 0, commentWithBE);

         if(result)
         {
            Print("BUY Order Executed: Lot Size = ", lots, ", SL = ", sl);

            // Now place SELL_LIMIT orders for partial exits
            bool allLimitsPlaced = true;

            // TP1
            double tp1Lots = NormalizeDouble(calc.partialLots1, 2);
            if(tp1Lots < minLot) tp1Lots = minLot;
            if(tp1Lots > maxLot) tp1Lots = maxLot;
            tp1Lots = MathFloor(tp1Lots / lotStep) * lotStep;

            double tp1Price = NormalizeDouble(calc.partialTP1Price, g_Digits);
            bool tp1Result = trade.OrderOpen(_Symbol, ORDER_TYPE_SELL_LIMIT, tp1Lots, 0, tp1Price, 0, 0, ORDER_TIME_GTC, 0, "TP1 @ " + DoubleToString(calc.partialPips1, 1) + " pips");

            if(tp1Result)
               Print("TP1 SELL_LIMIT placed: ", tp1Lots, " lots @ ", tp1Price);
            else
            {
               Print("TP1 SELL_LIMIT failed: ", trade.ResultRetcodeDescription());
               allLimitsPlaced = false;
            }

            // TP2
            double tp2Lots = NormalizeDouble(calc.partialLots2, 2);
            if(tp2Lots < minLot) tp2Lots = minLot;
            if(tp2Lots > maxLot) tp2Lots = maxLot;
            tp2Lots = MathFloor(tp2Lots / lotStep) * lotStep;

            double tp2Price = NormalizeDouble(calc.partialTP2Price, g_Digits);
            bool tp2Result = trade.OrderOpen(_Symbol, ORDER_TYPE_SELL_LIMIT, tp2Lots, 0, tp2Price, 0, 0, ORDER_TIME_GTC, 0, "TP2 @ " + DoubleToString(calc.partialPips2, 1) + " pips");

            if(tp2Result)
               Print("TP2 SELL_LIMIT placed: ", tp2Lots, " lots @ ", tp2Price);
            else
            {
               Print("TP2 SELL_LIMIT failed: ", trade.ResultRetcodeDescription());
               allLimitsPlaced = false;
            }

            // TP3 (if enabled)
            if(inpNumberOfLevels == 3)
            {
               double tp3Lots = NormalizeDouble(calc.partialLots3, 2);
               if(tp3Lots < minLot) tp3Lots = minLot;
               if(tp3Lots > maxLot) tp3Lots = maxLot;
               tp3Lots = MathFloor(tp3Lots / lotStep) * lotStep;

               double tp3Price = NormalizeDouble(calc.partialTP3Price, g_Digits);
               bool tp3Result = trade.OrderOpen(_Symbol, ORDER_TYPE_SELL_LIMIT, tp3Lots, 0, tp3Price, 0, 0, ORDER_TIME_GTC, 0, "TP3 @ " + DoubleToString(calc.partialPips3, 1) + " pips");

               if(tp3Result)
                  Print("TP3 SELL_LIMIT placed: ", tp3Lots, " lots @ ", tp3Price);
               else
               {
                  Print("TP3 SELL_LIMIT failed: ", trade.ResultRetcodeDescription());
                  allLimitsPlaced = false;
               }
            }

            if(allLimitsPlaced)
               Comment("OK BUY Order & Partial Exit Limits Placed Successfully!\nLot Size: ", lots, "\nSL: ", sl);
            else
               Comment("OK BUY Order Placed, but some Partial Exit Limits Failed!\nCheck Journal for details.");
         }
         else
         {
            Print("BUY Order Failed: ", trade.ResultRetcodeDescription());
            Comment("✗ BUY Order Failed: ", trade.ResultRetcodeDescription());
         }
      }
   }
   else
   {
      // Don't place SL/TP with order
      result = trade.Buy(lots, _Symbol, ask, 0, 0, commentWithBE);

      if(result)
      {
         Print("BUY Order Executed: Lot Size = ", lots, " (No SL/TP)");
         Comment("OK BUY Order Placed Successfully!\nLot Size: ", lots, "\n(No SL/TP placed)");
      }
      else
      {
         Print("BUY Order Failed: ", trade.ResultRetcodeDescription());
         Comment("✗ BUY Order Failed: ", trade.ResultRetcodeDescription());
      }
   }
}

//+------------------------------------------------------------------+
//| Execute Sell Order                                                |
//+------------------------------------------------------------------+
void ExecuteSellOrder()
{
   RiskCalculation calc = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? g_ConservativeCalc : g_IdealCalc;

   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double sl = NormalizeDouble(calc.slPrice, g_Digits);
   double lots = NormalizeDouble(calc.lotSize, 2);

   // Validate lot size
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);

   if(lots < minLot) lots = minLot;
   if(lots > maxLot) lots = maxLot;
   lots = MathFloor(lots / lotStep) * lotStep;

   trade.SetExpertMagicNumber(123456);
   trade.SetDeviationInPoints(10);

   // Calculate and lock in BE pips at order placement
   double bePips = CalculateBEPipsForOrder(lots);
   string baseComment = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? "RM_Sell_CONS" : "RM_Sell_IDEAL";
   string commentWithBE = baseComment + "|BE:" + DoubleToString(bePips, 2);

   bool result = false;
   double tp = 0;

   // Determine TP based on inpPlaceSLTP setting
   if(inpPlaceSLTP)
   {
      if(inpTPMethod == TP_STANDARD)
      {
         // Standard TP: Place order with SL and TP
         tp = inpShowTP ? NormalizeDouble(calc.tpPrice, g_Digits) : 0;
         result = trade.Sell(lots, _Symbol, bid, sl, tp, commentWithBE);

         if(result)
         {
            Print("SELL Order Executed: Lot Size = ", lots, ", SL = ", sl, ", TP = ", tp);
            Comment("OK SELL Order Placed Successfully!\nLot Size: ", lots, "\nSL: ", sl, "\nTP: ", tp);
         }
         else
         {
            Print("SELL Order Failed: ", trade.ResultRetcodeDescription());
            Comment("✗ SELL Order Failed: ", trade.ResultRetcodeDescription());
         }
      }
      else // TP_PARTIAL_EXITS
      {
         // Partial Exits: Place main order with SL only, then place limit orders for each level
         result = trade.Sell(lots, _Symbol, bid, sl, 0, commentWithBE);

         if(result)
         {
            Print("SELL Order Executed: Lot Size = ", lots, ", SL = ", sl);

            // Now place BUY_LIMIT orders for partial exits
            bool allLimitsPlaced = true;

            // TP1
            double tp1Lots = NormalizeDouble(calc.partialLots1, 2);
            if(tp1Lots < minLot) tp1Lots = minLot;
            if(tp1Lots > maxLot) tp1Lots = maxLot;
            tp1Lots = MathFloor(tp1Lots / lotStep) * lotStep;

            double tp1Price = NormalizeDouble(calc.partialTP1Price, g_Digits);
            bool tp1Result = trade.OrderOpen(_Symbol, ORDER_TYPE_BUY_LIMIT, tp1Lots, 0, tp1Price, 0, 0, ORDER_TIME_GTC, 0, "TP1 @ " + DoubleToString(calc.partialPips1, 1) + " pips");

            if(tp1Result)
               Print("TP1 BUY_LIMIT placed: ", tp1Lots, " lots @ ", tp1Price);
            else
            {
               Print("TP1 BUY_LIMIT failed: ", trade.ResultRetcodeDescription());
               allLimitsPlaced = false;
            }

            // TP2
            double tp2Lots = NormalizeDouble(calc.partialLots2, 2);
            if(tp2Lots < minLot) tp2Lots = minLot;
            if(tp2Lots > maxLot) tp2Lots = maxLot;
            tp2Lots = MathFloor(tp2Lots / lotStep) * lotStep;

            double tp2Price = NormalizeDouble(calc.partialTP2Price, g_Digits);
            bool tp2Result = trade.OrderOpen(_Symbol, ORDER_TYPE_BUY_LIMIT, tp2Lots, 0, tp2Price, 0, 0, ORDER_TIME_GTC, 0, "TP2 @ " + DoubleToString(calc.partialPips2, 1) + " pips");

            if(tp2Result)
               Print("TP2 BUY_LIMIT placed: ", tp2Lots, " lots @ ", tp2Price);
            else
            {
               Print("TP2 BUY_LIMIT failed: ", trade.ResultRetcodeDescription());
               allLimitsPlaced = false;
            }

            // TP3 (if enabled)
            if(inpNumberOfLevels == 3)
            {
               double tp3Lots = NormalizeDouble(calc.partialLots3, 2);
               if(tp3Lots < minLot) tp3Lots = minLot;
               if(tp3Lots > maxLot) tp3Lots = maxLot;
               tp3Lots = MathFloor(tp3Lots / lotStep) * lotStep;

               double tp3Price = NormalizeDouble(calc.partialTP3Price, g_Digits);
               bool tp3Result = trade.OrderOpen(_Symbol, ORDER_TYPE_BUY_LIMIT, tp3Lots, 0, tp3Price, 0, 0, ORDER_TIME_GTC, 0, "TP3 @ " + DoubleToString(calc.partialPips3, 1) + " pips");

               if(tp3Result)
                  Print("TP3 BUY_LIMIT placed: ", tp3Lots, " lots @ ", tp3Price);
               else
               {
                  Print("TP3 BUY_LIMIT failed: ", trade.ResultRetcodeDescription());
                  allLimitsPlaced = false;
               }
            }

            if(allLimitsPlaced)
               Comment("OK SELL Order & Partial Exit Limits Placed Successfully!\nLot Size: ", lots, "\nSL: ", sl);
            else
               Comment("OK SELL Order Placed, but some Partial Exit Limits Failed!\nCheck Journal for details.");
         }
         else
         {
            Print("SELL Order Failed: ", trade.ResultRetcodeDescription());
            Comment("✗ SELL Order Failed: ", trade.ResultRetcodeDescription());
         }
      }
   }
   else
   {
      // Don't place SL/TP with order
      result = trade.Sell(lots, _Symbol, bid, 0, 0, commentWithBE);

      if(result)
      {
         Print("SELL Order Executed: Lot Size = ", lots, " (No SL/TP)");
         Comment("OK SELL Order Placed Successfully!\nLot Size: ", lots, "\n(No SL/TP placed)");
      }
      else
      {
         Print("SELL Order Failed: ", trade.ResultRetcodeDescription());
         Comment("✗ SELL Order Failed: ", trade.ResultRetcodeDescription());
      }
   }
}

//+------------------------------------------------------------------+
//| Update label position and text (for draggable lines)             |
//+------------------------------------------------------------------+
void UpdateLabelPosition(string labelName, double price, string text)
{
   datetime labelTime;
   int anchor;
   double labelPrice = price;

   // Calculate label position based on user setting
   if(inpLabelPosition == LABEL_RIGHT)
   {
      // Position to the right
      labelTime = TimeCurrent() + PeriodSeconds(PERIOD_CURRENT) * 5;
      anchor = ANCHOR_LEFT;
   }
   else if(inpLabelPosition == LABEL_ABOVE)
   {
      // Position above the line
      labelTime = TimeCurrent();
      anchor = ANCHOR_LEFT_LOWER;
      labelPrice = price + (5 * g_Point);  // 5 points above
   }
   else  // LABEL_BELOW
   {
      // Position below the line
      labelTime = TimeCurrent();
      anchor = ANCHOR_LEFT_UPPER;
      labelPrice = price - (5 * g_Point);  // 5 points below
   }

   // Update position
   ObjectSetInteger(0, labelName, OBJPROP_TIME, labelTime);
   ObjectSetDouble(0, labelName, OBJPROP_PRICE, labelPrice);
   ObjectSetInteger(0, labelName, OBJPROP_ANCHOR, anchor);
   ObjectSetString(0, labelName, OBJPROP_TEXT, text);
}

//+------------------------------------------------------------------+
//| Update Reference Lines                                            |
//+------------------------------------------------------------------+
void UpdateLines()
{
   if(!inpShowLines) return;

   // Trade Management Mode: Skip planning lines, show only actual order lines
   if(inpTradeManagementMode)
   {
      // Delete planning lines if they exist
      if(ObjectFind(0, g_SLLineName) >= 0) ObjectDelete(0, g_SLLineName);
      if(ObjectFind(0, g_TPLineName) >= 0) ObjectDelete(0, g_TPLineName);
      if(ObjectFind(0, g_EntryLineName) >= 0) ObjectDelete(0, g_EntryLineName);
      if(ObjectFind(0, g_BELineName) >= 0) ObjectDelete(0, g_BELineName);
      if(ObjectFind(0, g_PartialTP1LineName) >= 0) ObjectDelete(0, g_PartialTP1LineName);
      if(ObjectFind(0, g_PartialTP2LineName) >= 0) ObjectDelete(0, g_PartialTP2LineName);
      if(ObjectFind(0, g_PartialTP3LineName) >= 0) ObjectDelete(0, g_PartialTP3LineName);
      return;  // Skip drawing planning lines
   }

   RiskCalculation calc = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? g_ConservativeCalc : g_IdealCalc;
   
   datetime currentTime = TimeCurrent();
   datetime futureTime = currentTime + PeriodSeconds(PERIOD_CURRENT) * 100;
   
   // Stop Loss Line
   bool isDynamicSL = (inpSLMode == SL_DYNAMIC);

   if(ObjectFind(0, g_SLLineName) < 0)
   {
      ObjectCreate(0, g_SLLineName, OBJ_TREND, 0, currentTime, calc.slPrice, futureTime, calc.slPrice);
      ObjectSetInteger(0, g_SLLineName, OBJPROP_COLOR, inpSLLineColor);
      ObjectSetInteger(0, g_SLLineName, OBJPROP_WIDTH, 2);
      ObjectSetInteger(0, g_SLLineName, OBJPROP_STYLE, STYLE_SOLID);
      ObjectSetInteger(0, g_SLLineName, OBJPROP_RAY_RIGHT, true);
      ObjectSetString(0, g_SLLineName, OBJPROP_TEXT, "SL: " + DoubleToString(calc.slPips, 1) + " pips");
   }
   else
   {
      ObjectMove(0, g_SLLineName, 0, currentTime, calc.slPrice);
      ObjectMove(0, g_SLLineName, 1, futureTime, calc.slPrice);
   }

   // Make line draggable in Dynamic mode
   ObjectSetInteger(0, g_SLLineName, OBJPROP_SELECTABLE, isDynamicSL);

   // Add text label showing pip count (for both Manual and Dynamic modes)
   double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double slPips = MathAbs(currentPrice - calc.slPrice) / g_PipValue;
   string slLabel = "SL: " + DoubleToString(slPips, 1) + " pips";

   if(ObjectFind(0, g_SLLabelName) < 0)
   {
      ObjectCreate(0, g_SLLabelName, OBJ_TEXT, 0, TimeCurrent(), calc.slPrice);
      ObjectSetInteger(0, g_SLLabelName, OBJPROP_COLOR, inpSLLineColor);
      ObjectSetInteger(0, g_SLLabelName, OBJPROP_FONTSIZE, 8);
   }
   UpdateLabelPosition(g_SLLabelName, calc.slPrice, slLabel);
   
   // Take Profit Line(s)
   if(inpShowTP)
   {
      if(inpTPMethod == TP_PARTIAL_EXITS)
      {
         // Draw partial exit lines
         double exitPercent3 = (inpNumberOfLevels == 3) ? (100 - inpExitPercent1 - inpExitPercent2) : 0;
         bool isManualLevels = (inpPartialMethod == PARTIAL_MANUAL);

         // Level 1
         if(ObjectFind(0, g_PartialTP1LineName) < 0)
         {
            ObjectCreate(0, g_PartialTP1LineName, OBJ_TREND, 0, currentTime, calc.partialTP1Price, futureTime, calc.partialTP1Price);
            ObjectSetInteger(0, g_PartialTP1LineName, OBJPROP_COLOR, inpTPLineColor);
            ObjectSetInteger(0, g_PartialTP1LineName, OBJPROP_WIDTH, 2);
            ObjectSetInteger(0, g_PartialTP1LineName, OBJPROP_STYLE, STYLE_SOLID);
            ObjectSetInteger(0, g_PartialTP1LineName, OBJPROP_RAY_RIGHT, true);
            ObjectSetString(0, g_PartialTP1LineName, OBJPROP_TEXT, "TP1: " + DoubleToString(inpExitPercent1, 0) + "% @ +" + DoubleToString(calc.partialPips1, 1) + " pips");
         }
         else
         {
            ObjectMove(0, g_PartialTP1LineName, 0, currentTime, calc.partialTP1Price);
            ObjectMove(0, g_PartialTP1LineName, 1, futureTime, calc.partialTP1Price);
            ObjectSetString(0, g_PartialTP1LineName, OBJPROP_TEXT, "TP1: " + DoubleToString(inpExitPercent1, 0) + "% @ +" + DoubleToString(calc.partialPips1, 1) + " pips");
         }

         // Make line draggable in Manual Levels mode
         ObjectSetInteger(0, g_PartialTP1LineName, OBJPROP_SELECTABLE, isManualLevels);

         // Add text label for TP1
         double slPips = (isDynamicSL) ? MathAbs(SymbolInfoDouble(_Symbol, SYMBOL_BID) - calc.slPrice) / g_PipValue : calc.slPips;
         double rr1 = (slPips > 0) ? (calc.partialPips1 / slPips) : 0;
         string tp1Label = "TP1: " + DoubleToString(inpExitPercent1, 0) + "% @ " + DoubleToString(calc.partialPips1, 1) + " pips";
         if(rr1 > 0) tp1Label += " | RR: " + DoubleToString(rr1, 2);
         tp1Label += " | Net: $" + DoubleToString(calc.partialNetPnL1, 2);

         if(ObjectFind(0, g_PartialTP1LabelName) < 0)
         {
            ObjectCreate(0, g_PartialTP1LabelName, OBJ_TEXT, 0, TimeCurrent(), calc.partialTP1Price);
            ObjectSetInteger(0, g_PartialTP1LabelName, OBJPROP_COLOR, inpTPLineColor);
            ObjectSetInteger(0, g_PartialTP1LabelName, OBJPROP_FONTSIZE, 8);
         }
         UpdateLabelPosition(g_PartialTP1LabelName, calc.partialTP1Price, tp1Label);
         
         // Level 2
         if(ObjectFind(0, g_PartialTP2LineName) < 0)
         {
            ObjectCreate(0, g_PartialTP2LineName, OBJ_TREND, 0, currentTime, calc.partialTP2Price, futureTime, calc.partialTP2Price);
            ObjectSetInteger(0, g_PartialTP2LineName, OBJPROP_COLOR, inpTPLineColor);
            ObjectSetInteger(0, g_PartialTP2LineName, OBJPROP_WIDTH, 2);
            ObjectSetInteger(0, g_PartialTP2LineName, OBJPROP_STYLE, STYLE_SOLID);
            ObjectSetInteger(0, g_PartialTP2LineName, OBJPROP_RAY_RIGHT, true);
            ObjectSetString(0, g_PartialTP2LineName, OBJPROP_TEXT, "TP2: " + DoubleToString(inpExitPercent2, 0) + "% @ +" + DoubleToString(calc.partialPips2, 1) + " pips");
         }
         else
         {
            ObjectMove(0, g_PartialTP2LineName, 0, currentTime, calc.partialTP2Price);
            ObjectMove(0, g_PartialTP2LineName, 1, futureTime, calc.partialTP2Price);
            ObjectSetString(0, g_PartialTP2LineName, OBJPROP_TEXT, "TP2: " + DoubleToString(inpExitPercent2, 0) + "% @ +" + DoubleToString(calc.partialPips2, 1) + " pips");
         }

         // Make line draggable in Manual Levels mode
         ObjectSetInteger(0, g_PartialTP2LineName, OBJPROP_SELECTABLE, isManualLevels);

         // Add text label for TP2
         double rr2 = (slPips > 0) ? (calc.partialPips2 / slPips) : 0;
         string tp2Label = "TP2: " + DoubleToString(inpExitPercent2, 0) + "% @ " + DoubleToString(calc.partialPips2, 1) + " pips";
         if(rr2 > 0) tp2Label += " | RR: " + DoubleToString(rr2, 2);
         tp2Label += " | Net: $" + DoubleToString(calc.partialNetPnL2, 2);

         if(ObjectFind(0, g_PartialTP2LabelName) < 0)
         {
            ObjectCreate(0, g_PartialTP2LabelName, OBJ_TEXT, 0, TimeCurrent(), calc.partialTP2Price);
            ObjectSetInteger(0, g_PartialTP2LabelName, OBJPROP_COLOR, inpTPLineColor);
            ObjectSetInteger(0, g_PartialTP2LabelName, OBJPROP_FONTSIZE, 8);
         }
         UpdateLabelPosition(g_PartialTP2LabelName, calc.partialTP2Price, tp2Label);
         
         // Level 3 (if enabled)
         if(inpNumberOfLevels == 3)
         {
            if(ObjectFind(0, g_PartialTP3LineName) < 0)
            {
               ObjectCreate(0, g_PartialTP3LineName, OBJ_TREND, 0, currentTime, calc.partialTP3Price, futureTime, calc.partialTP3Price);
               ObjectSetInteger(0, g_PartialTP3LineName, OBJPROP_COLOR, inpTPLineColor);
               ObjectSetInteger(0, g_PartialTP3LineName, OBJPROP_WIDTH, 2);
               ObjectSetInteger(0, g_PartialTP3LineName, OBJPROP_STYLE, STYLE_DASH);
               ObjectSetInteger(0, g_PartialTP3LineName, OBJPROP_RAY_RIGHT, true);
               ObjectSetString(0, g_PartialTP3LineName, OBJPROP_TEXT, "TP3: " + DoubleToString(exitPercent3, 0) + "% @ +" + DoubleToString(calc.partialPips3, 1) + " pips");
            }
            else
            {
               ObjectMove(0, g_PartialTP3LineName, 0, currentTime, calc.partialTP3Price);
               ObjectMove(0, g_PartialTP3LineName, 1, futureTime, calc.partialTP3Price);
               ObjectSetString(0, g_PartialTP3LineName, OBJPROP_TEXT, "TP3: " + DoubleToString(exitPercent3, 0) + "% @ +" + DoubleToString(calc.partialPips3, 1) + " pips");
            }

            // Make line draggable in Manual Levels mode
            ObjectSetInteger(0, g_PartialTP3LineName, OBJPROP_SELECTABLE, isManualLevels);

            // Add text label for TP3
            double rr3 = (slPips > 0) ? (calc.partialPips3 / slPips) : 0;
            string tp3Label = "TP3: " + DoubleToString(exitPercent3, 0) + "% @ " + DoubleToString(calc.partialPips3, 1) + " pips";
            if(rr3 > 0) tp3Label += " | RR: " + DoubleToString(rr3, 2);
            tp3Label += " | Net: $" + DoubleToString(calc.partialNetPnL3, 2);

            if(ObjectFind(0, g_PartialTP3LabelName) < 0)
            {
               ObjectCreate(0, g_PartialTP3LabelName, OBJ_TEXT, 0, TimeCurrent(), calc.partialTP3Price);
               ObjectSetInteger(0, g_PartialTP3LabelName, OBJPROP_COLOR, inpTPLineColor);
               ObjectSetInteger(0, g_PartialTP3LabelName, OBJPROP_FONTSIZE, 8);
            }
            UpdateLabelPosition(g_PartialTP3LabelName, calc.partialTP3Price, tp3Label);
         }
         else
         {
            // Delete TP3 line and label if it exists but 2 levels selected
            if(ObjectFind(0, g_PartialTP3LineName) >= 0)
               ObjectDelete(0, g_PartialTP3LineName);
            if(ObjectFind(0, g_PartialTP3LabelName) >= 0)
               ObjectDelete(0, g_PartialTP3LabelName);
         }
         
         // Delete standard TP line and label if they exist
         if(ObjectFind(0, g_TPLineName) >= 0)
            ObjectDelete(0, g_TPLineName);
         if(ObjectFind(0, g_TPLabelName) >= 0)
            ObjectDelete(0, g_TPLabelName);
      }
      else
      {
         // Standard TP line
         bool isDynamicTP = (inpTPMode == TP_DYNAMIC);

         if(ObjectFind(0, g_TPLineName) < 0)
         {
            ObjectCreate(0, g_TPLineName, OBJ_TREND, 0, currentTime, calc.tpPrice, futureTime, calc.tpPrice);
            ObjectSetInteger(0, g_TPLineName, OBJPROP_COLOR, inpTPLineColor);
            ObjectSetInteger(0, g_TPLineName, OBJPROP_WIDTH, 2);
            ObjectSetInteger(0, g_TPLineName, OBJPROP_STYLE, STYLE_SOLID);
            ObjectSetInteger(0, g_TPLineName, OBJPROP_RAY_RIGHT, true);
            ObjectSetString(0, g_TPLineName, OBJPROP_TEXT, "TP: " + DoubleToString(calc.tpPips, 1) + " pips");
         }
         else
         {
            ObjectMove(0, g_TPLineName, 0, currentTime, calc.tpPrice);
            ObjectMove(0, g_TPLineName, 1, futureTime, calc.tpPrice);
         }

         // Make line draggable in Dynamic mode
         ObjectSetInteger(0, g_TPLineName, OBJPROP_SELECTABLE, isDynamicTP);

         // Add text label showing pips, RR, and Net profit
         double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         double slPips = (isDynamicSL) ? MathAbs(currentPrice - calc.slPrice) / g_PipValue : calc.slPips;
         double tpPips = MathAbs(calc.tpPrice - currentPrice) / g_PipValue;
         double rrRatio = (tpPips > 0 && slPips > 0) ? (tpPips / slPips) : 0;

         string tpLabel = "TP: " + DoubleToString(tpPips, 1) + " pips";
         if(rrRatio > 0) tpLabel += " | RR: " + DoubleToString(rrRatio, 2);
         tpLabel += " | Net: $" + DoubleToString(calc.netTP, 2);

         if(ObjectFind(0, g_TPLabelName) < 0)
         {
            ObjectCreate(0, g_TPLabelName, OBJ_TEXT, 0, TimeCurrent(), calc.tpPrice);
            ObjectSetInteger(0, g_TPLabelName, OBJPROP_COLOR, inpTPLineColor);
            ObjectSetInteger(0, g_TPLabelName, OBJPROP_FONTSIZE, 8);
         }
         UpdateLabelPosition(g_TPLabelName, calc.tpPrice, tpLabel);

         // Delete partial exit lines and labels if they exist
         if(ObjectFind(0, g_PartialTP1LineName) >= 0)
            ObjectDelete(0, g_PartialTP1LineName);
         if(ObjectFind(0, g_PartialTP1LabelName) >= 0)
            ObjectDelete(0, g_PartialTP1LabelName);
         if(ObjectFind(0, g_PartialTP2LineName) >= 0)
            ObjectDelete(0, g_PartialTP2LineName);
         if(ObjectFind(0, g_PartialTP2LabelName) >= 0)
            ObjectDelete(0, g_PartialTP2LabelName);
         if(ObjectFind(0, g_PartialTP3LineName) >= 0)
            ObjectDelete(0, g_PartialTP3LineName);
         if(ObjectFind(0, g_PartialTP3LabelName) >= 0)
            ObjectDelete(0, g_PartialTP3LabelName);
      }
   }
   
   // Entry Line
   if(inpShowEntryLine)
   {
      if(ObjectFind(0, g_EntryLineName) < 0)
      {
         ObjectCreate(0, g_EntryLineName, OBJ_TREND, 0, currentTime, calc.entryPrice, futureTime, calc.entryPrice);
         ObjectSetInteger(0, g_EntryLineName, OBJPROP_COLOR, inpEntryLineColor);
         ObjectSetInteger(0, g_EntryLineName, OBJPROP_WIDTH, 2);
         ObjectSetInteger(0, g_EntryLineName, OBJPROP_STYLE, STYLE_DOT);
         ObjectSetInteger(0, g_EntryLineName, OBJPROP_RAY_RIGHT, true);
         ObjectSetInteger(0, g_EntryLineName, OBJPROP_SELECTABLE, false);
         string entryLabel = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? "Entry (w/ Slippage)" : "Entry";
         ObjectSetString(0, g_EntryLineName, OBJPROP_TEXT, entryLabel);
      }
      else
      {
         ObjectMove(0, g_EntryLineName, 0, currentTime, calc.entryPrice);
         ObjectMove(0, g_EntryLineName, 1, futureTime, calc.entryPrice);
      }
   }
   
   // Break-even Line
   if(inpShowBreakEvenLine)
   {
      // Determine trade direction from SL position
      bool isLongTrade = (calc.slPrice < calc.entryPrice);

      double bePrice;
      if(isLongTrade)
         bePrice = calc.entryPrice + (calc.breakEvenPips * g_PipValue);  // BUY: BE above entry
      else
         bePrice = calc.entryPrice - (calc.breakEvenPips * g_PipValue);  // SELL: BE below entry

      if(ObjectFind(0, g_BELineName) < 0)
      {
         ObjectCreate(0, g_BELineName, OBJ_TREND, 0, currentTime, bePrice, futureTime, bePrice);
         ObjectSetInteger(0, g_BELineName, OBJPROP_COLOR, inpBELineColor);
         ObjectSetInteger(0, g_BELineName, OBJPROP_WIDTH, 1);
         ObjectSetInteger(0, g_BELineName, OBJPROP_STYLE, STYLE_DASH);
         ObjectSetInteger(0, g_BELineName, OBJPROP_RAY_RIGHT, true);
         ObjectSetInteger(0, g_BELineName, OBJPROP_SELECTABLE, false);
         ObjectSetString(0, g_BELineName, OBJPROP_TEXT, "BE (Planning): " + DoubleToString(calc.breakEvenPips, 2) + " pips");
      }
      else
      {
         ObjectMove(0, g_BELineName, 0, currentTime, bePrice);
         ObjectMove(0, g_BELineName, 1, futureTime, bePrice);
      }
   }
}

//+------------------------------------------------------------------+
//| Delete Lines                                                      |
//+------------------------------------------------------------------+
void DeleteLines()
{
   ObjectDelete(0, g_SLLineName);
   ObjectDelete(0, g_TPLineName);
   ObjectDelete(0, g_EntryLineName);
   ObjectDelete(0, g_BELineName);
   ObjectDelete(0, g_PartialTP1LineName);
   ObjectDelete(0, g_PartialTP2LineName);
   ObjectDelete(0, g_PartialTP3LineName);
   // Delete all TP line labels
   ObjectDelete(0, g_SLLabelName);
   ObjectDelete(0, g_TPLabelName);
   ObjectDelete(0, g_PartialTP1LabelName);
   ObjectDelete(0, g_PartialTP2LabelName);
   ObjectDelete(0, g_PartialTP3LabelName);
}

//+------------------------------------------------------------------+
//| Draw Actual Order Lines (Entry & BE for placed orders)           |
//+------------------------------------------------------------------+
void DrawActualOrderLines()
{
   datetime currentTime = TimeCurrent();
   datetime futureTime = currentTime + PeriodSeconds(PERIOD_CURRENT) * 100;

   // Track which tickets we're drawing
   string existingTickets = "";

   // Loop through all positions
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket <= 0) continue;

      // Filter: only process positions for this symbol and magic number
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      if(PositionGetInteger(POSITION_MAGIC) != 123456) continue;

      // Get position details
      double actualEntry = PositionGetDouble(POSITION_PRICE_OPEN);
      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
      string comment = PositionGetString(POSITION_COMMENT);

      // Parse BE pips from comment
      double actualBEPips = 0;
      int bePos = StringFind(comment, "|BE:");
      if(bePos >= 0)
      {
         string beStr = StringSubstr(comment, bePos + 4);
         actualBEPips = StringToDouble(beStr);
      }
      else
      {
         // Fallback: Calculate BE for old orders
         double actualLotSize = PositionGetDouble(POSITION_VOLUME);
         actualBEPips = CalculateBEPipsForOrder(actualLotSize);
      }

      // Add offset to BE
      double totalBEPips = actualBEPips + inpBEOffsetPips;

      // Calculate BE price
      double bePrice;
      if(posType == POSITION_TYPE_BUY)
         bePrice = actualEntry + (totalBEPips * g_PipValue);
      else
         bePrice = actualEntry - (totalBEPips * g_PipValue);

      // Create unique line names
      string entryLineName = "ActualEntry_" + IntegerToString(ticket);
      string beLineName = "ActualBE_" + IntegerToString(ticket);

      existingTickets += IntegerToString(ticket) + ",";

      // Draw Actual Entry Line
      if(ObjectFind(0, entryLineName) < 0)
      {
         ObjectCreate(0, entryLineName, OBJ_TREND, 0, currentTime, actualEntry, futureTime, actualEntry);
         ObjectSetInteger(0, entryLineName, OBJPROP_COLOR, clrDodgerBlue);
         ObjectSetInteger(0, entryLineName, OBJPROP_WIDTH, 2);
         ObjectSetInteger(0, entryLineName, OBJPROP_STYLE, STYLE_SOLID);
         ObjectSetInteger(0, entryLineName, OBJPROP_RAY_RIGHT, true);
         ObjectSetInteger(0, entryLineName, OBJPROP_SELECTABLE, false);
         string typeStr = (posType == POSITION_TYPE_BUY) ? "BUY" : "SELL";
         ObjectSetString(0, entryLineName, OBJPROP_TEXT, "Entry #" + IntegerToString(ticket) + " (" + typeStr + ")");
      }
      else
      {
         ObjectMove(0, entryLineName, 0, currentTime, actualEntry);
         ObjectMove(0, entryLineName, 1, futureTime, actualEntry);
      }

      // Draw Actual BE Line
      if(ObjectFind(0, beLineName) < 0)
      {
         ObjectCreate(0, beLineName, OBJ_TREND, 0, currentTime, bePrice, futureTime, bePrice);
         ObjectSetInteger(0, beLineName, OBJPROP_COLOR, clrGold);
         ObjectSetInteger(0, beLineName, OBJPROP_WIDTH, 2);
         ObjectSetInteger(0, beLineName, OBJPROP_STYLE, STYLE_DOT);
         ObjectSetInteger(0, beLineName, OBJPROP_RAY_RIGHT, true);
         ObjectSetInteger(0, beLineName, OBJPROP_SELECTABLE, false);
         ObjectSetString(0, beLineName, OBJPROP_TEXT, "BE #" + IntegerToString(ticket) + " (" + DoubleToString(totalBEPips, 2) + " pips)");
      }
      else
      {
         ObjectMove(0, beLineName, 0, currentTime, bePrice);
         ObjectMove(0, beLineName, 1, futureTime, bePrice);
      }
   }

   // Clean up lines for closed positions
   for(int i = ObjectsTotal(0, 0, OBJ_TREND) - 1; i >= 0; i--)
   {
      string objName = ObjectName(0, i, 0, OBJ_TREND);

      // Check if it's an actual order line
      if(StringFind(objName, "ActualEntry_") == 0 || StringFind(objName, "ActualBE_") == 0)
      {
         // Extract ticket from name
         string ticketStr = "";
         if(StringFind(objName, "ActualEntry_") == 0)
            ticketStr = StringSubstr(objName, 12);  // Skip "ActualEntry_"
         else
            ticketStr = StringSubstr(objName, 9);   // Skip "ActualBE_"

         // If ticket not in existing list, delete the line
         if(StringFind(existingTickets, ticketStr + ",") < 0)
         {
            ObjectDelete(0, objName);
         }
      }
   }
}
