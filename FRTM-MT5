//+------------------------------------------------------------------+
//|                                           ForexRiskManager.mq5    |
//|                                  Risk Management & Lot Calculator |
//|                                                                    |
//+------------------------------------------------------------------+
#property copyright "Forex Risk Manager"
#property link      ""
#property version   "1.00"
#property description "Risk Management EA with Lot Size Calculator"
#property description "Ideal & Conservative Modes | One-Click Execution"

//--- Include libraries
#include <Trade\Trade.mqh>
CTrade trade;

//+------------------------------------------------------------------+
//| Enumerations - MUST BE BEFORE INPUTS                            |
//+------------------------------------------------------------------+
enum ENUM_PIP_MODE
{
   PIP_AUTO,           // Auto Calculate
   PIP_MANUAL          // Manual Entry
};

enum ENUM_SL_MODE
{
   SL_MANUAL,          // Manual (Fixed Pips)
   SL_DYNAMIC          // Dynamic (to Price Level)
};

enum ENUM_TP_MODE
{
   TP_RR_MULTIPLE,     // Risk/Reward Multiple
   TP_DYNAMIC          // Dynamic (to Price Level)
};

enum ENUM_TP_METHOD
{
   TP_STANDARD,        // Standard TP
   TP_PARTIAL_EXITS    // Partial Exits
};

enum ENUM_PARTIAL_METHOD
{
   PARTIAL_RR,         // RR Multiples
   PARTIAL_MANUAL      // Manual Levels
};

enum ENUM_DISPLAY_MODE
{
   DISPLAY_IDEAL,           // Ideal (No Entry Slippage)
   DISPLAY_CONSERVATIVE     // Conservative (With Entry Slippage)
};

//+------------------------------------------------------------------+
//| Input Parameters                                                  |
//+------------------------------------------------------------------+

//--- Stop Loss Settings
input group "ðŸ›‘ Stop Loss Settings"
input ENUM_SL_MODE inpSLMode = SL_MANUAL;                    // Stop Loss Mode
input double inpManualSLPips = 15.0;                         // Manual Stop Loss (pips)
input double inpDynamicSLPrice = 0.0;                        // Dynamic SL Price Level

//--- Take Profit Settings
input group "ðŸŽ¯ Take Profit Settings"
input bool inpShowTP = true;                                 // Show Take Profit Lines
input ENUM_TP_METHOD inpTPMethod = TP_STANDARD;             // Take Profit Method
input ENUM_TP_MODE inpTPMode = TP_RR_MULTIPLE;              // Take Profit Mode (Standard)
input double inpRRMultiple = 2.0;                           // Risk/Reward Multiple (Standard)
input double inpDynamicTPPrice = 0.0;                       // Dynamic TP Price Level

//--- Partial Exits Settings
input group "ðŸŽ¯ Partial Exits"
input int inpNumberOfLevels = 3;                            // Number of Exit Levels (2 or 3)
input ENUM_PARTIAL_METHOD inpPartialMethod = PARTIAL_RR;    // Partial Exit Method
input double inpExitPercent1 = 50.0;                        // Exit % at Level 1
input double inpExitPercent2 = 30.0;                        // Exit % at Level 2

//--- Partial Exits - RR Multiples
input group "ðŸŽ¯ Partial Exits - RR Multiples"
input double inpRRTarget1 = 1.0;                            // Level 1 RR Multiple
input double inpRRTarget2Overall = 1.5;                     // Level 2 Overall RR
input double inpRRTarget3Overall = 2.0;                     // Level 3 Overall RR

//--- Partial Exits - Manual Levels
input group "ðŸŽ¯ Partial Exits - Manual Levels"
input double inpPartialTP1Price = 0.0;                      // Level 1 Price
input double inpPartialTP2Price = 0.0;                      // Level 2 Price
input double inpPartialTP3Price = 0.0;                      // Level 3 Price

//--- Account & Risk Settings
input group "ðŸ’° Account & Risk Settings"
input double inpAccountSize = 100000;                       // Account Size (USD)
input double inpRiskPercent = 1.0;                          // Risk % per Trade
input double inpMarginPercent = 3.33;                       // Margin Requirement %
input double inpCommissionPerLot = 7.0;                     // Commission per Lot (Round-turn USD)
input ENUM_PIP_MODE inpPipValueMode = PIP_AUTO;            // Pip Value Mode
input double inpManualPipValue = 10.0;                      // Manual Pip Value (USD per lot)
input bool inpShowPipValue = true;                          // Show Pip Value in Panel

//--- Entry & Exit Slippage Settings
input group "âš¡ Entry & Exit Slippage"
input double inpEntrySlippage = 1.0;                        // Expected Entry Slippage (pips)
input double inpExitSlippage = 0.5;                         // Expected Exit Slippage (pips)
input ENUM_DISPLAY_MODE inpDisplayMode = DISPLAY_CONSERVATIVE; // Display Mode
input bool inpShowAlternateLotSize = true;                  // Show Alternate Lot Size

//--- Display Settings
input group "ðŸ“Š Display Settings"
input bool inpShowPanel = true;                             // Show Information Panel
input bool inpShowLines = true;                             // Show Reference Lines
input bool inpShowEntryLine = true;                         // Show Entry Line
input bool inpShowBreakEvenLine = false;                    // Show Break-even Line
input bool inpShowReturnOnMargin = true;                    // Show Return on Margin
input int inpPanelX = 20;                                   // Panel X Position
input int inpPanelY = 80;                                   // Panel Y Position
input color inpPanelBgColor = clrWhite;                     // Panel Background Color
input color inpPanelTextColor = clrBlack;                   // Panel Text Color
input color inpSLLineColor = clrRed;                        // Stop Loss Line Color
input color inpTPLineColor = clrGreen;                      // Take Profit Line Color
input color inpEntryLineColor = clrBlue;                    // Entry Line Color
input color inpBELineColor = clrOrange;                     // Break-even Line Color

//--- Button Settings
input group "ðŸ”˜ Button Settings"
input int inpButtonWidth = 100;                             // Button Width
input int inpButtonHeight = 30;                             // Button Height
input color inpBuyButtonColor = C'0,128,0';                 // Buy Button Color
input color inpSellButtonColor = C'178,34,34';              // Sell Button Color

//+------------------------------------------------------------------+
//| Global Variables                                                  |
//+------------------------------------------------------------------+
string g_PanelName = "RiskPanel";
string g_BuyButtonName = "BuyButton";
string g_SellButtonName = "SellButton";
string g_SLLineName = "SLLine";
string g_TPLineName = "TPLine";
string g_EntryLineName = "EntryLine";
string g_BELineName = "BELine";
string g_PartialTP1LineName = "PartialTP1Line";
string g_PartialTP2LineName = "PartialTP2Line";
string g_PartialTP3LineName = "PartialTP3Line";

double g_PointValue;
double g_PipValue;
int g_Digits;
double g_Point;

// Calculation results
struct RiskCalculation
{
   double lotSize;
   double priceRisk;
   double commission;
   double totalRisk;
   double riskPercent;
   double slPips;
   double baseSLPips;      // Original SL distance (without entry slippage)
   double tpPips;
   double slPrice;
   double tpPrice;
   double entryPrice;
   double breakEvenPips;
   double grossTP;
   double netTP;
   double marginRequired;
   double buyingPowerPercent;
   double returnOnMargin;
   
   // Partial exits
   double partialLots1;
   double partialLots2;
   double partialLots3;
   double partialPips1;
   double partialPips2;
   double partialPips3;
   double partialTP1Price;
   double partialTP2Price;
   double partialTP3Price;
   double partialNetPnL1;
   double partialNetPnL2;
   double partialNetPnL3;
   double partialTotalNetPnL;
};

RiskCalculation g_IdealCalc;
RiskCalculation g_ConservativeCalc;

//+------------------------------------------------------------------+
//| Expert initialization function                                    |
//+------------------------------------------------------------------+
int OnInit()
{
   //--- Initialize symbol info
   g_Digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
   g_Point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   //--- Calculate pip value
   string baseCurrency = SymbolInfoString(_Symbol, SYMBOL_CURRENCY_BASE);
   string quoteCurrency = SymbolInfoString(_Symbol, SYMBOL_CURRENCY_PROFIT);
   
   // Determine pip size
   if(StringFind(baseCurrency, "JPY") >= 0 || StringFind(quoteCurrency, "JPY") >= 0)
      g_PipValue = 0.01;
   else if(g_Digits == 5 || g_Digits == 3)
      g_PipValue = g_Point * 10;
   else
      g_PipValue = g_Point;
   
   //--- Calculate point value per standard lot (USD per point per lot)
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double contractSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_CONTRACT_SIZE);
   
   if(tickSize != 0 && tickValue != 0)
      g_PointValue = (tickValue / tickSize) * g_Point;
   else
   {
      // Fallback calculation
      double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      if(quoteCurrency == "USD")
         g_PointValue = g_Point * contractSize; // Direct USD quote
      else
         g_PointValue = (g_Point * contractSize) / bid; // Cross pair
   }
   
   // Use manual pip value if mode is set to manual
   double pipValuePerLot = (inpPipValueMode == PIP_MANUAL) ? inpManualPipValue : (g_PointValue * (g_PipValue / g_Point));
   
   Print("Symbol: ", _Symbol);
   Print("Digits: ", g_Digits);
   Print("Point: ", g_Point);
   Print("Pip Value: ", g_PipValue);
   Print("Point Value per lot: $", g_PointValue);
   Print("Pip Value per lot: $", pipValuePerLot);
   Print("Pip Value Mode: ", (inpPipValueMode == PIP_MANUAL ? "Manual" : "Auto"));
   Print("Base Currency: ", baseCurrency);
   Print("Quote Currency: ", quoteCurrency);
   Print("Contract Size: ", contractSize);
   Print("Tick Size: ", tickSize);
   Print("Tick Value: ", tickValue);
   
   //--- Create UI
   CreatePanel();
   CreateButtons();
   
   //--- Initial calculation
   CalculateRisk();
   UpdatePanel();
   UpdateLines();
   
   //--- Set timer for updates
   EventSetTimer(1);
   
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   //--- Kill timer
   EventKillTimer();
   
   //--- Delete all objects
   DeletePanel();
   DeleteButtons();
   DeleteLines();
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   //--- Recalculate on every tick
   CalculateRisk();
   UpdatePanel();
   UpdateLines();
}

//+------------------------------------------------------------------+
//| Timer function                                                    |
//+------------------------------------------------------------------+
void OnTimer()
{
   //--- Update display
   if(inpShowPanel)
      UpdatePanel();
}

//+------------------------------------------------------------------+
//| ChartEvent function                                              |
//+------------------------------------------------------------------+
void OnChartEvent(const int id,
                  const long &lparam,
                  const double &dparam,
                  const string &sparam)
{
   //--- Check for button clicks
   if(id == CHARTEVENT_OBJECT_CLICK)
   {
      if(sparam == g_BuyButtonName)
      {
         ExecuteBuyOrder();
         ObjectSetInteger(0, g_BuyButtonName, OBJPROP_STATE, false);
      }
      else if(sparam == g_SellButtonName)
      {
         ExecuteSellOrder();
         ObjectSetInteger(0, g_SellButtonName, OBJPROP_STATE, false);
      }
   }
}

//+------------------------------------------------------------------+
//| Calculate Risk and Lot Sizes                                     |
//+------------------------------------------------------------------+
void CalculateRisk()
{
   double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   
   //--- Determine SL distance in pips
   double slPips = 0;
   double slPrice = 0;
   bool isLongTrade = true;  // Determine trade direction
   
   if(inpSLMode == SL_MANUAL)
   {
      slPips = inpManualSLPips;
      // Assume long for manual mode (user can change SL position to indicate short)
      slPrice = currentPrice - (slPips * g_PipValue);
      isLongTrade = true;
   }
   else // SL_DYNAMIC
   {
      if(inpDynamicSLPrice > 0)
      {
         slPrice = inpDynamicSLPrice;
         slPips = MathAbs(currentPrice - slPrice) / g_PipValue;
         // Determine direction: if SL is below current price = LONG, if above = SHORT
         isLongTrade = (slPrice < currentPrice);
      }
      else
      {
         slPips = inpManualSLPips;
         slPrice = currentPrice - (slPips * g_PipValue);
         isLongTrade = true;
      }
   }
   
   //--- IDEAL CALCULATION (No Entry Slippage)
   double idealTotalPips = slPips + inpExitSlippage;
   double riskAmount = inpAccountSize * (inpRiskPercent / 100.0);
   
   // Calculate pip value in USD for the lot size calculation
   double pipValuePerLot = (inpPipValueMode == PIP_MANUAL) ? inpManualPipValue : (g_PointValue * (g_PipValue / g_Point));
   
   g_IdealCalc.baseSLPips = slPips;  // Store base SL
   g_IdealCalc.slPips = slPips;
   g_IdealCalc.lotSize = riskAmount / ((idealTotalPips * pipValuePerLot) + inpCommissionPerLot);
   g_IdealCalc.commission = g_IdealCalc.lotSize * inpCommissionPerLot;
   g_IdealCalc.priceRisk = g_IdealCalc.lotSize * idealTotalPips * pipValuePerLot;
   g_IdealCalc.totalRisk = g_IdealCalc.priceRisk + g_IdealCalc.commission;
   g_IdealCalc.riskPercent = (g_IdealCalc.totalRisk / inpAccountSize) * 100.0;
   g_IdealCalc.entryPrice = currentPrice;
   g_IdealCalc.slPrice = slPrice;
   
   // Break-even calculation
   double idealTotalFees = g_IdealCalc.commission + (g_IdealCalc.lotSize * inpExitSlippage * pipValuePerLot);
   g_IdealCalc.breakEvenPips = idealTotalFees / (g_IdealCalc.lotSize * pipValuePerLot);
   
   // Take Profit calculation
   double idealCommissionPips = g_IdealCalc.commission / (g_IdealCalc.lotSize * pipValuePerLot);
   double idealTotalRiskPips = slPips + inpExitSlippage + idealCommissionPips;
   
   if(inpTPMode == TP_RR_MULTIPLE)
   {
      g_IdealCalc.tpPips = idealTotalRiskPips * inpRRMultiple;
   }
   else // TP_DYNAMIC
   {
      if(inpDynamicTPPrice > 0)
      {
         g_IdealCalc.tpPips = MathAbs(inpDynamicTPPrice - currentPrice) / g_PipValue;
      }
      else
      {
         g_IdealCalc.tpPips = idealTotalRiskPips * inpRRMultiple;
      }
   }
   
   g_IdealCalc.tpPrice = isLongTrade ? (currentPrice + (g_IdealCalc.tpPips * g_PipValue)) : (currentPrice - (g_IdealCalc.tpPips * g_PipValue));
   g_IdealCalc.grossTP = g_IdealCalc.lotSize * g_IdealCalc.tpPips * pipValuePerLot;
   double idealExitSlippageCost = g_IdealCalc.lotSize * inpExitSlippage * pipValuePerLot;
   g_IdealCalc.netTP = g_IdealCalc.grossTP - idealExitSlippageCost - g_IdealCalc.commission;
   
   // Margin calculation
   double idealContractValue = g_IdealCalc.lotSize * 100000;
   double idealNotionalUSD = idealContractValue * currentPrice;
   g_IdealCalc.marginRequired = idealNotionalUSD * (inpMarginPercent / 100.0);
   g_IdealCalc.buyingPowerPercent = (g_IdealCalc.marginRequired / inpAccountSize) * 100.0;
   g_IdealCalc.returnOnMargin = g_IdealCalc.marginRequired > 0 ? (g_IdealCalc.netTP / g_IdealCalc.marginRequired) * 100.0 : 0;
   
   //--- CONSERVATIVE CALCULATION (With Entry Slippage)
   double effectiveSL = slPips + inpEntrySlippage;
   double conservativeTotalPips = effectiveSL + inpExitSlippage;
   
   g_ConservativeCalc.baseSLPips = slPips;  // Store base SL
   g_ConservativeCalc.slPips = effectiveSL;
   g_ConservativeCalc.lotSize = riskAmount / ((conservativeTotalPips * pipValuePerLot) + inpCommissionPerLot);
   g_ConservativeCalc.commission = g_ConservativeCalc.lotSize * inpCommissionPerLot;
   g_ConservativeCalc.priceRisk = g_ConservativeCalc.lotSize * conservativeTotalPips * pipValuePerLot;
   g_ConservativeCalc.totalRisk = g_ConservativeCalc.priceRisk + g_ConservativeCalc.commission;
   g_ConservativeCalc.riskPercent = (g_ConservativeCalc.totalRisk / inpAccountSize) * 100.0;
   // Entry price accounting for slippage based on direction
   g_ConservativeCalc.entryPrice = isLongTrade ? (currentPrice + (inpEntrySlippage * g_PipValue)) : (currentPrice - (inpEntrySlippage * g_PipValue));
   g_ConservativeCalc.slPrice = slPrice;
   
   // Break-even calculation
   double conservativeTotalFees = g_ConservativeCalc.commission + (g_ConservativeCalc.lotSize * inpExitSlippage * pipValuePerLot);
   g_ConservativeCalc.breakEvenPips = conservativeTotalFees / (g_ConservativeCalc.lotSize * pipValuePerLot);
   
   // Take Profit calculation
   double conservativeCommissionPips = g_ConservativeCalc.commission / (g_ConservativeCalc.lotSize * pipValuePerLot);
   double conservativeTotalRiskPips = effectiveSL + inpExitSlippage + conservativeCommissionPips;
   
   if(inpTPMode == TP_RR_MULTIPLE)
   {
      g_ConservativeCalc.tpPips = conservativeTotalRiskPips * inpRRMultiple;
   }
   else // TP_DYNAMIC
   {
      if(inpDynamicTPPrice > 0)
      {
         g_ConservativeCalc.tpPips = MathAbs(inpDynamicTPPrice - g_ConservativeCalc.entryPrice) / g_PipValue;
      }
      else
      {
         g_ConservativeCalc.tpPips = conservativeTotalRiskPips * inpRRMultiple;
      }
   }
   
   g_ConservativeCalc.tpPrice = isLongTrade ? (g_ConservativeCalc.entryPrice + (g_ConservativeCalc.tpPips * g_PipValue)) : (g_ConservativeCalc.entryPrice - (g_ConservativeCalc.tpPips * g_PipValue));
   g_ConservativeCalc.grossTP = g_ConservativeCalc.lotSize * g_ConservativeCalc.tpPips * pipValuePerLot;
   double conservativeExitSlippageCost = g_ConservativeCalc.lotSize * inpExitSlippage * pipValuePerLot;
   g_ConservativeCalc.netTP = g_ConservativeCalc.grossTP - conservativeExitSlippageCost - g_ConservativeCalc.commission;
   
   // Margin calculation
   double conservativeContractValue = g_ConservativeCalc.lotSize * 100000;
   double conservativeNotionalUSD = conservativeContractValue * currentPrice;
   g_ConservativeCalc.marginRequired = conservativeNotionalUSD * (inpMarginPercent / 100.0);
   g_ConservativeCalc.buyingPowerPercent = (g_ConservativeCalc.marginRequired / inpAccountSize) * 100.0;
   g_ConservativeCalc.returnOnMargin = g_ConservativeCalc.marginRequired > 0 ? (g_ConservativeCalc.netTP / g_ConservativeCalc.marginRequired) * 100.0 : 0;
   
   //--- PARTIAL EXITS CALCULATION
   if(inpTPMethod == TP_PARTIAL_EXITS)
   {
      CalculatePartialExits(g_IdealCalc, pipValuePerLot, isLongTrade);
      CalculatePartialExits(g_ConservativeCalc, pipValuePerLot, isLongTrade);
   }
}

//+------------------------------------------------------------------+
//| Create Information Panel                                          |
//+------------------------------------------------------------------+
void CreatePanel()
{
   if(!inpShowPanel) return;
   
   int x = inpPanelX;
   int y = inpPanelY;
   int width = 280;
   int rowHeight = 20;
   
   // Create background rectangle - use solid color, no transparency for RECTANGLE_LABEL
   ObjectCreate(0, g_PanelName, OBJ_RECTANGLE_LABEL, 0, 0, 0);
   ObjectSetInteger(0, g_PanelName, OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, g_PanelName, OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, g_PanelName, OBJPROP_XSIZE, width);
   ObjectSetInteger(0, g_PanelName, OBJPROP_YSIZE, 520);
   ObjectSetInteger(0, g_PanelName, OBJPROP_BGCOLOR, inpPanelBgColor);
   ObjectSetInteger(0, g_PanelName, OBJPROP_BORDER_TYPE, BORDER_FLAT);
   ObjectSetInteger(0, g_PanelName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
   ObjectSetInteger(0, g_PanelName, OBJPROP_COLOR, clrBlack);
   ObjectSetInteger(0, g_PanelName, OBJPROP_STYLE, STYLE_SOLID);
   ObjectSetInteger(0, g_PanelName, OBJPROP_WIDTH, 1);
   ObjectSetInteger(0, g_PanelName, OBJPROP_BACK, false);  // Changed to false so it's on top
   ObjectSetInteger(0, g_PanelName, OBJPROP_SELECTABLE, false);
   ObjectSetInteger(0, g_PanelName, OBJPROP_SELECTED, false);
   ObjectSetInteger(0, g_PanelName, OBJPROP_HIDDEN, true);
}

//+------------------------------------------------------------------+
//| Update Information Panel                                          |
//+------------------------------------------------------------------+
void UpdatePanel()
{
   if(!inpShowPanel) return;
   
   int x = inpPanelX + 10;
   int y = inpPanelY + 10;
   int rowHeight = 18;
   int currentRow = 0;
   
   // Get the display calculation based on mode
   RiskCalculation display = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? g_ConservativeCalc : g_IdealCalc;
   RiskCalculation alternate = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? g_IdealCalc : g_ConservativeCalc;
   string modeLabel = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? " (Conservative)" : " (Ideal)";
   string altModeLabel = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? " (Ideal)" : " (Conservative)";
   
   // Title
   CreateLabel("PanelTitle", "RISK CALCULATOR", x + 60, y + (currentRow * rowHeight), clrDodgerBlue, 10, "Arial Bold");
   currentRow++;
   
   CreateLabel("PanelMode", modeLabel, x + 90, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   currentRow += 2;
   
   // Lot Size
   CreateLabel("LotSizeLabel", "ðŸ’¼ Lot Size:", x, y + (currentRow * rowHeight), inpPanelTextColor, 9, "Arial Bold");
   color lotColor = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? clrOrangeRed : clrDodgerBlue;
   CreateLabel("LotSizeValue", DoubleToString(display.lotSize, 2), x + 180, y + (currentRow * rowHeight), lotColor, 9, "Arial Bold");
   currentRow++;
   
   if(inpShowAlternateLotSize)
   {
      CreateLabel("AltLotSizeLabel", "Lot Size" + altModeLabel + ":", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
      color altColor = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? clrDodgerBlue : clrOrangeRed;
      CreateLabel("AltLotSizeValue", DoubleToString(alternate.lotSize, 2), x + 180, y + (currentRow * rowHeight), altColor, 8, "Arial");
      currentRow++;
   }
   
   // Pip Value Display
   if(inpShowPipValue)
   {
      double pipValuePerLot = (inpPipValueMode == PIP_MANUAL) ? inpManualPipValue : (g_PointValue * (g_PipValue / g_Point));
      string pipValueLabel = (inpPipValueMode == PIP_MANUAL) ? "Pip Value (Manual):" : "Pip Value (Auto):";
      CreateLabel("PipValueLabel", pipValueLabel, x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
      CreateLabel("PipValueValue", "$" + DoubleToString(pipValuePerLot, 2), x + 180, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
      currentRow++;
   }
   
   currentRow++;
   CreateLabel("Divider1", "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€", x, y + (currentRow * rowHeight), clrGray, 8, "Arial");
   currentRow++;
   
   // Stop Loss Structure
   string slModeText = (inpSLMode == SL_MANUAL) ? "Base SL:" : "Base SL (Dynamic):";
   CreateLabel("SLLabel", slModeText, x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   CreateLabel("SLValue", DoubleToString(display.baseSLPips, 1) + " pips", x + 180, y + (currentRow * rowHeight), clrRed, 8, "Arial");
   currentRow++;
   
   double totalRiskPips = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? (display.slPips + inpExitSlippage) : (display.slPips + inpExitSlippage);
   CreateLabel("TotalRiskPipsLabel", "Total Risk Distance:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   CreateLabel("TotalRiskPipsValue", DoubleToString(totalRiskPips, 1) + " pips", x + 180, y + (currentRow * rowHeight), clrRed, 8, "Arial");
   currentRow++;
   
   // Take Profit Display
   if(inpShowTP)
   {
      if(inpTPMethod == TP_PARTIAL_EXITS)
      {
         // Show partial exits summary
         double exitPercent3 = (inpNumberOfLevels == 3) ? (100 - inpExitPercent1 - inpExitPercent2) : 0;
         string partialMethodLabel = (inpPartialMethod == PARTIAL_RR) ? " (RR)" : " (Manual)";
         
         CreateLabel("TPLabel", "Partial Exits" + partialMethodLabel + ":", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
         CreateLabel("TPValue", IntegerToString(inpNumberOfLevels) + " Levels", x + 180, y + (currentRow * rowHeight), clrGreen, 8, "Arial");
         currentRow++;
      }
      else
      {
         string tpModeText = (inpTPMode == TP_RR_MULTIPLE) ? "Take Profit (RR: " + DoubleToString(inpRRMultiple, 1) + "):" : "Take Profit (Dynamic):";
         CreateLabel("TPLabel", tpModeText, x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
         CreateLabel("TPValue", DoubleToString(display.tpPips, 1) + " pips", x + 180, y + (currentRow * rowHeight), clrGreen, 8, "Arial");
         currentRow++;
      }
   }
   
   CreateLabel("BELabel", "Break-even:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   CreateLabel("BEValue", DoubleToString(display.breakEvenPips, 2) + " pips", x + 180, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   currentRow++;
   
   currentRow++;
   CreateLabel("Divider2", "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€", x, y + (currentRow * rowHeight), clrGray, 8, "Arial");
   currentRow++;
   
   // Risk Breakdown
   CreateLabel("PriceRiskLabel", "Price Risk:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   CreateLabel("PriceRiskValue", "$" + DoubleToString(display.priceRisk, 2), x + 180, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   currentRow++;
   
   CreateLabel("CommLabel", "Commission:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   CreateLabel("CommValue", "$" + DoubleToString(display.commission, 2), x + 180, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   currentRow++;
   
   CreateLabel("TotalRiskLabel", "Total Risk:", x, y + (currentRow * rowHeight), inpPanelTextColor, 9, "Arial Bold");
   CreateLabel("TotalRiskValue", "$" + DoubleToString(display.totalRisk, 2), x + 180, y + (currentRow * rowHeight), clrRed, 9, "Arial Bold");
   currentRow++;
   
   CreateLabel("RiskPercentLabel", "Actual Risk %:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   CreateLabel("RiskPercentValue", DoubleToString(display.riskPercent, 2) + "%", x + 180, y + (currentRow * rowHeight), clrRed, 8, "Arial");
   currentRow++;
   
   if(inpShowTP)
   {
      if(inpTPMethod == TP_PARTIAL_EXITS)
      {
         // Show partial exits details
         double exitPercent3 = (inpNumberOfLevels == 3) ? (100 - inpExitPercent1 - inpExitPercent2) : 0;
         
         CreateLabel("PartialTitle", "Partial Exits Breakdown:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial Bold");
         currentRow++;
         
         // Level 1 - condensed
         CreateLabel("Level1Label", "L1: " + DoubleToString(inpExitPercent1, 0) + "% (" + DoubleToString(display.partialLots1, 2) + " lots)", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
         currentRow++;
         CreateLabel("Level1Pips", "  +" + DoubleToString(display.partialPips1, 1) + " pips", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
         CreateLabel("Level1Net", "$" + DoubleToString(display.partialNetPnL1, 2), x + 180, y + (currentRow * rowHeight), clrGreen, 8, "Arial");
         currentRow++;
         
         // Level 2 - condensed
         CreateLabel("Level2Label", "L2: " + DoubleToString(inpExitPercent2, 0) + "% (" + DoubleToString(display.partialLots2, 2) + " lots)", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
         currentRow++;
         CreateLabel("Level2Pips", "  +" + DoubleToString(display.partialPips2, 1) + " pips", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
         CreateLabel("Level2Net", "$" + DoubleToString(display.partialNetPnL2, 2), x + 180, y + (currentRow * rowHeight), clrGreen, 8, "Arial");
         currentRow++;
         
         // Level 3 (if enabled) - condensed
         if(inpNumberOfLevels == 3)
         {
            CreateLabel("Level3Label", "L3: " + DoubleToString(exitPercent3, 0) + "% (" + DoubleToString(display.partialLots3, 2) + " lots)", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
            currentRow++;
            CreateLabel("Level3Pips", "  +" + DoubleToString(display.partialPips3, 1) + " pips", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
            CreateLabel("Level3Net", "$" + DoubleToString(display.partialNetPnL3, 2), x + 180, y + (currentRow * rowHeight), clrGreen, 8, "Arial");
            currentRow++;
         }
         
         CreateLabel("PartialTotalLabel", "Total Net P&L:", x, y + (currentRow * rowHeight), inpPanelTextColor, 9, "Arial Bold");
         CreateLabel("PartialTotalValue", "$" + DoubleToString(display.partialTotalNetPnL, 2), x + 180, y + (currentRow * rowHeight), clrGreen, 9, "Arial Bold");
         currentRow++;
      }
      else
      {
         CreateLabel("NetTPLabel", "Net Take Profit:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
         CreateLabel("NetTPValue", "$" + DoubleToString(display.netTP, 2), x + 180, y + (currentRow * rowHeight), clrGreen, 8, "Arial");
         currentRow++;
      }
   }
   
   currentRow++;
   CreateLabel("Divider3", "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€", x, y + (currentRow * rowHeight), clrGray, 8, "Arial");
   currentRow++;
   
   // Margin Info
   CreateLabel("MarginLabel", "Margin Required:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   CreateLabel("MarginValue", "$" + DoubleToString(display.marginRequired, 2), x + 180, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   currentRow++;
   
   CreateLabel("BuyingPowerLabel", "Buying Power:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
   CreateLabel("BuyingPowerValue", DoubleToString(display.buyingPowerPercent, 2) + "%", x + 180, y + (currentRow * rowHeight), clrGreen, 8, "Arial");
   currentRow++;
   
   if(inpShowReturnOnMargin)
   {
      CreateLabel("ROMLabel", "Return on Margin:", x, y + (currentRow * rowHeight), inpPanelTextColor, 8, "Arial");
      color romColor = (display.returnOnMargin > 0) ? clrGreen : clrRed;
      CreateLabel("ROMValue", DoubleToString(display.returnOnMargin, 2) + "%", x + 180, y + (currentRow * rowHeight), romColor, 8, "Arial");
      currentRow++;
   }
   
   ChartRedraw(0);
}

//+------------------------------------------------------------------+
//| Create Label Helper                                              |
//+------------------------------------------------------------------+
void CreateLabel(string name, string text, int x, int y, color clr, int fontSize = 8, string font = "Arial")
{
   string objName = g_PanelName + "_" + name;
   
   if(ObjectFind(0, objName) < 0)
   {
      ObjectCreate(0, objName, OBJ_LABEL, 0, 0, 0);
      ObjectSetInteger(0, objName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, objName, OBJPROP_ANCHOR, ANCHOR_LEFT_UPPER);
      ObjectSetInteger(0, objName, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(0, objName, OBJPROP_HIDDEN, true);
   }
   
   ObjectSetInteger(0, objName, OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, objName, OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, objName, OBJPROP_COLOR, clr);
   ObjectSetInteger(0, objName, OBJPROP_FONTSIZE, fontSize);
   ObjectSetString(0, objName, OBJPROP_FONT, font);
   ObjectSetString(0, objName, OBJPROP_TEXT, text);
}

//+------------------------------------------------------------------+
//| Delete Panel                                                      |
//+------------------------------------------------------------------+
void DeletePanel()
{
   ObjectsDeleteAll(0, g_PanelName);
}

//+------------------------------------------------------------------+
//| Create Buy/Sell Buttons                                          |
//+------------------------------------------------------------------+
void CreateButtons()
{
   int buttonY = inpPanelY + 530;
   
   // Buy Button
   ObjectCreate(0, g_BuyButtonName, OBJ_BUTTON, 0, 0, 0);
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_XDISTANCE, inpPanelX);
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_YDISTANCE, buttonY);
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_XSIZE, inpButtonWidth);
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_YSIZE, inpButtonHeight);
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_BGCOLOR, inpBuyButtonColor);
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_COLOR, clrWhite);
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_FONTSIZE, 10);
   ObjectSetString(0, g_BuyButtonName, OBJPROP_FONT, "Arial Bold");
   ObjectSetString(0, g_BuyButtonName, OBJPROP_TEXT, "BUY");
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_SELECTABLE, false);
   ObjectSetInteger(0, g_BuyButtonName, OBJPROP_HIDDEN, true);
   
   // Sell Button
   ObjectCreate(0, g_SellButtonName, OBJ_BUTTON, 0, 0, 0);
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_XDISTANCE, inpPanelX + inpButtonWidth + 10);
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_YDISTANCE, buttonY);
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_XSIZE, inpButtonWidth);
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_YSIZE, inpButtonHeight);
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_BGCOLOR, inpSellButtonColor);
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_COLOR, clrWhite);
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_FONTSIZE, 10);
   ObjectSetString(0, g_SellButtonName, OBJPROP_FONT, "Arial Bold");
   ObjectSetString(0, g_SellButtonName, OBJPROP_TEXT, "SELL");
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_SELECTABLE, false);
   ObjectSetInteger(0, g_SellButtonName, OBJPROP_HIDDEN, true);
}

//+------------------------------------------------------------------+
//| Delete Buttons                                                    |
//+------------------------------------------------------------------+
void DeleteButtons()
{
   ObjectDelete(0, g_BuyButtonName);
   ObjectDelete(0, g_SellButtonName);
}

//+------------------------------------------------------------------+
//| Calculate Partial Exits                                          |
//+------------------------------------------------------------------+
void CalculatePartialExits(RiskCalculation &calc, double pipValuePerLot, bool isLongTrade)
{
   // Calculate exit percentages
   double exitPercent3 = (inpNumberOfLevels == 3) ? (100 - inpExitPercent1 - inpExitPercent2) : 0;
   if(exitPercent3 < 0) exitPercent3 = 0;
   
   // Calculate lot sizes for each level
   calc.partialLots1 = calc.lotSize * (inpExitPercent1 / 100.0);
   calc.partialLots2 = calc.lotSize * (inpExitPercent2 / 100.0);
   calc.partialLots3 = (inpNumberOfLevels == 3) ? calc.lotSize * (exitPercent3 / 100.0) : 0;
   
   if(inpPartialMethod == PARTIAL_RR)
   {
      // RR Multiples Method
      // Level 1: Exit X% to NET inpRRTarget1 * total risk
      double targetNet1 = calc.totalRisk * inpRRTarget1;
      double feesExit1 = (calc.partialLots1 * inpCommissionPerLot) + (calc.partialLots1 * inpExitSlippage * pipValuePerLot);
      double grossNeeded1 = targetNet1 + feesExit1;
      calc.partialPips1 = grossNeeded1 / (calc.partialLots1 * pipValuePerLot);
      calc.partialNetPnL1 = targetNet1;
      
      if(inpNumberOfLevels == 2)
      {
         // Level 2: Remaining % reaches overall target
         double overallTarget2 = calc.totalRisk * inpRRTarget2Overall;
         double stillNeeded2 = overallTarget2 - targetNet1;
         double feesExit2 = (calc.partialLots2 * inpCommissionPerLot) + (calc.partialLots2 * inpExitSlippage * pipValuePerLot);
         double grossNeeded2 = stillNeeded2 + feesExit2;
         calc.partialPips2 = grossNeeded2 / (calc.partialLots2 * pipValuePerLot);
         calc.partialNetPnL2 = stillNeeded2;
         
         calc.partialTotalNetPnL = calc.partialNetPnL1 + calc.partialNetPnL2;
      }
      else
      {
         // Level 2: Reach intermediate target
         double overallTarget2 = calc.totalRisk * inpRRTarget2Overall;
         double stillNeeded2 = overallTarget2 - targetNet1;
         double feesExit2 = (calc.partialLots2 * inpCommissionPerLot) + (calc.partialLots2 * inpExitSlippage * pipValuePerLot);
         double grossNeeded2 = stillNeeded2 + feesExit2;
         calc.partialPips2 = grossNeeded2 / (calc.partialLots2 * pipValuePerLot);
         calc.partialNetPnL2 = stillNeeded2;
         
         // Level 3: Reach final target
         double overallTarget3 = calc.totalRisk * inpRRTarget3Overall;
         double stillNeeded3 = overallTarget3 - overallTarget2;
         double feesExit3 = (calc.partialLots3 * inpCommissionPerLot) + (calc.partialLots3 * inpExitSlippage * pipValuePerLot);
         double grossNeeded3 = stillNeeded3 + feesExit3;
         calc.partialPips3 = grossNeeded3 / (calc.partialLots3 * pipValuePerLot);
         calc.partialNetPnL3 = stillNeeded3;
         
         calc.partialTotalNetPnL = calc.partialNetPnL1 + calc.partialNetPnL2 + calc.partialNetPnL3;
      }
      
      // Convert to price levels
      if(isLongTrade)
      {
         calc.partialTP1Price = calc.entryPrice + (calc.partialPips1 * g_PipValue);
         calc.partialTP2Price = calc.entryPrice + (calc.partialPips2 * g_PipValue);
         calc.partialTP3Price = (inpNumberOfLevels == 3) ? calc.entryPrice + (calc.partialPips3 * g_PipValue) : 0;
      }
      else
      {
         calc.partialTP1Price = calc.entryPrice - (calc.partialPips1 * g_PipValue);
         calc.partialTP2Price = calc.entryPrice - (calc.partialPips2 * g_PipValue);
         calc.partialTP3Price = (inpNumberOfLevels == 3) ? calc.entryPrice - (calc.partialPips3 * g_PipValue) : 0;
      }
   }
   else // PARTIAL_MANUAL
   {
      // Manual Levels
      calc.partialTP1Price = inpPartialTP1Price;
      calc.partialTP2Price = inpPartialTP2Price;
      calc.partialTP3Price = (inpNumberOfLevels == 3) ? inpPartialTP3Price : 0;
      
      // Calculate pips from manual prices
      if(isLongTrade)
      {
         calc.partialPips1 = (calc.partialTP1Price - calc.entryPrice) / g_PipValue;
         calc.partialPips2 = (calc.partialTP2Price - calc.entryPrice) / g_PipValue;
         calc.partialPips3 = (inpNumberOfLevels == 3) ? (calc.partialTP3Price - calc.entryPrice) / g_PipValue : 0;
      }
      else
      {
         calc.partialPips1 = (calc.entryPrice - calc.partialTP1Price) / g_PipValue;
         calc.partialPips2 = (calc.entryPrice - calc.partialTP2Price) / g_PipValue;
         calc.partialPips3 = (inpNumberOfLevels == 3) ? (calc.entryPrice - calc.partialTP3Price) / g_PipValue : 0;
      }
      
      // Calculate P&L for manual levels
      double totalFees = (calc.lotSize * inpCommissionPerLot) + (calc.lotSize * inpExitSlippage * pipValuePerLot);
      double partialFees1 = totalFees * (inpExitPercent1 / 100.0);
      double partialFees2 = totalFees * (inpExitPercent2 / 100.0);
      double partialFees3 = (inpNumberOfLevels == 3) ? totalFees * (exitPercent3 / 100.0) : 0;
      
      double partialGrossPnL1 = calc.partialLots1 * calc.partialPips1 * pipValuePerLot;
      double partialGrossPnL2 = calc.partialLots2 * calc.partialPips2 * pipValuePerLot;
      double partialGrossPnL3 = (inpNumberOfLevels == 3) ? calc.partialLots3 * calc.partialPips3 * pipValuePerLot : 0;
      
      calc.partialNetPnL1 = partialGrossPnL1 - partialFees1;
      calc.partialNetPnL2 = partialGrossPnL2 - partialFees2;
      calc.partialNetPnL3 = (inpNumberOfLevels == 3) ? partialGrossPnL3 - partialFees3 : 0;
      
      calc.partialTotalNetPnL = (inpNumberOfLevels == 3) ? 
         (calc.partialNetPnL1 + calc.partialNetPnL2 + calc.partialNetPnL3) : 
         (calc.partialNetPnL1 + calc.partialNetPnL2);
   }
}

//+------------------------------------------------------------------+
//| Execute Buy Order                                                 |
//+------------------------------------------------------------------+
void ExecuteBuyOrder()
{
   RiskCalculation calc = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? g_ConservativeCalc : g_IdealCalc;
   
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double sl = NormalizeDouble(calc.slPrice, g_Digits);
   double tp = inpShowTP ? NormalizeDouble(calc.tpPrice, g_Digits) : 0;
   double lots = NormalizeDouble(calc.lotSize, 2);
   
   // Validate lot size
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   if(lots < minLot) lots = minLot;
   if(lots > maxLot) lots = maxLot;
   lots = MathFloor(lots / lotStep) * lotStep;
   
   trade.SetExpertMagicNumber(123456);
   trade.SetDeviationInPoints(10);
   
   bool result = trade.Buy(lots, _Symbol, ask, sl, tp, "Risk Manager Buy");
   
   if(result)
   {
      Print("BUY Order Executed: Lot Size = ", lots, ", SL = ", sl, ", TP = ", tp);
      Comment("âœ“ BUY Order Placed Successfully!\nLot Size: ", lots, "\nSL: ", sl, "\nTP: ", tp);
   }
   else
   {
      Print("BUY Order Failed: ", trade.ResultRetcodeDescription());
      Comment("âœ— BUY Order Failed: ", trade.ResultRetcodeDescription());
   }
}

//+------------------------------------------------------------------+
//| Execute Sell Order                                                |
//+------------------------------------------------------------------+
void ExecuteSellOrder()
{
   RiskCalculation calc = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? g_ConservativeCalc : g_IdealCalc;
   
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double sl = NormalizeDouble(calc.slPrice, g_Digits);
   double tp = inpShowTP ? NormalizeDouble(calc.tpPrice, g_Digits) : 0;
   double lots = NormalizeDouble(calc.lotSize, 2);
   
   // Validate lot size
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   if(lots < minLot) lots = minLot;
   if(lots > maxLot) lots = maxLot;
   lots = MathFloor(lots / lotStep) * lotStep;
   
   trade.SetExpertMagicNumber(123456);
   trade.SetDeviationInPoints(10);
   
   bool result = trade.Sell(lots, _Symbol, bid, sl, tp, "Risk Manager Sell");
   
   if(result)
   {
      Print("SELL Order Executed: Lot Size = ", lots, ", SL = ", sl, ", TP = ", tp);
      Comment("âœ“ SELL Order Placed Successfully!\nLot Size: ", lots, "\nSL: ", sl, "\nTP: ", tp);
   }
   else
   {
      Print("SELL Order Failed: ", trade.ResultRetcodeDescription());
      Comment("âœ— SELL Order Failed: ", trade.ResultRetcodeDescription());
   }
}

//+------------------------------------------------------------------+
//| Update Reference Lines                                            |
//+------------------------------------------------------------------+
void UpdateLines()
{
   if(!inpShowLines) return;
   
   RiskCalculation calc = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? g_ConservativeCalc : g_IdealCalc;
   
   datetime currentTime = TimeCurrent();
   datetime futureTime = currentTime + PeriodSeconds(PERIOD_CURRENT) * 100;
   
   // Stop Loss Line
   if(ObjectFind(0, g_SLLineName) < 0)
   {
      ObjectCreate(0, g_SLLineName, OBJ_TREND, 0, currentTime, calc.slPrice, futureTime, calc.slPrice);
      ObjectSetInteger(0, g_SLLineName, OBJPROP_COLOR, inpSLLineColor);
      ObjectSetInteger(0, g_SLLineName, OBJPROP_WIDTH, 2);
      ObjectSetInteger(0, g_SLLineName, OBJPROP_STYLE, STYLE_SOLID);
      ObjectSetInteger(0, g_SLLineName, OBJPROP_RAY_RIGHT, true);
      ObjectSetInteger(0, g_SLLineName, OBJPROP_SELECTABLE, false);
      ObjectSetString(0, g_SLLineName, OBJPROP_TEXT, "SL: " + DoubleToString(calc.slPips, 1) + " pips");
   }
   else
   {
      ObjectMove(0, g_SLLineName, 0, currentTime, calc.slPrice);
      ObjectMove(0, g_SLLineName, 1, futureTime, calc.slPrice);
   }
   
   // Take Profit Line(s)
   if(inpShowTP)
   {
      if(inpTPMethod == TP_PARTIAL_EXITS)
      {
         // Draw partial exit lines
         double exitPercent3 = (inpNumberOfLevels == 3) ? (100 - inpExitPercent1 - inpExitPercent2) : 0;
         
         // Level 1
         if(ObjectFind(0, g_PartialTP1LineName) < 0)
         {
            ObjectCreate(0, g_PartialTP1LineName, OBJ_TREND, 0, currentTime, calc.partialTP1Price, futureTime, calc.partialTP1Price);
            ObjectSetInteger(0, g_PartialTP1LineName, OBJPROP_COLOR, inpTPLineColor);
            ObjectSetInteger(0, g_PartialTP1LineName, OBJPROP_WIDTH, 2);
            ObjectSetInteger(0, g_PartialTP1LineName, OBJPROP_STYLE, STYLE_SOLID);
            ObjectSetInteger(0, g_PartialTP1LineName, OBJPROP_RAY_RIGHT, true);
            ObjectSetInteger(0, g_PartialTP1LineName, OBJPROP_SELECTABLE, false);
            ObjectSetString(0, g_PartialTP1LineName, OBJPROP_TEXT, "TP1: " + DoubleToString(inpExitPercent1, 0) + "% @ +" + DoubleToString(calc.partialPips1, 1) + " pips");
         }
         else
         {
            ObjectMove(0, g_PartialTP1LineName, 0, currentTime, calc.partialTP1Price);
            ObjectMove(0, g_PartialTP1LineName, 1, futureTime, calc.partialTP1Price);
            ObjectSetString(0, g_PartialTP1LineName, OBJPROP_TEXT, "TP1: " + DoubleToString(inpExitPercent1, 0) + "% @ +" + DoubleToString(calc.partialPips1, 1) + " pips");
         }
         
         // Level 2
         if(ObjectFind(0, g_PartialTP2LineName) < 0)
         {
            ObjectCreate(0, g_PartialTP2LineName, OBJ_TREND, 0, currentTime, calc.partialTP2Price, futureTime, calc.partialTP2Price);
            ObjectSetInteger(0, g_PartialTP2LineName, OBJPROP_COLOR, inpTPLineColor);
            ObjectSetInteger(0, g_PartialTP2LineName, OBJPROP_WIDTH, 2);
            ObjectSetInteger(0, g_PartialTP2LineName, OBJPROP_STYLE, STYLE_SOLID);
            ObjectSetInteger(0, g_PartialTP2LineName, OBJPROP_RAY_RIGHT, true);
            ObjectSetInteger(0, g_PartialTP2LineName, OBJPROP_SELECTABLE, false);
            ObjectSetString(0, g_PartialTP2LineName, OBJPROP_TEXT, "TP2: " + DoubleToString(inpExitPercent2, 0) + "% @ +" + DoubleToString(calc.partialPips2, 1) + " pips");
         }
         else
         {
            ObjectMove(0, g_PartialTP2LineName, 0, currentTime, calc.partialTP2Price);
            ObjectMove(0, g_PartialTP2LineName, 1, futureTime, calc.partialTP2Price);
            ObjectSetString(0, g_PartialTP2LineName, OBJPROP_TEXT, "TP2: " + DoubleToString(inpExitPercent2, 0) + "% @ +" + DoubleToString(calc.partialPips2, 1) + " pips");
         }
         
         // Level 3 (if enabled)
         if(inpNumberOfLevels == 3)
         {
            if(ObjectFind(0, g_PartialTP3LineName) < 0)
            {
               ObjectCreate(0, g_PartialTP3LineName, OBJ_TREND, 0, currentTime, calc.partialTP3Price, futureTime, calc.partialTP3Price);
               ObjectSetInteger(0, g_PartialTP3LineName, OBJPROP_COLOR, inpTPLineColor);
               ObjectSetInteger(0, g_PartialTP3LineName, OBJPROP_WIDTH, 2);
               ObjectSetInteger(0, g_PartialTP3LineName, OBJPROP_STYLE, STYLE_DASH);
               ObjectSetInteger(0, g_PartialTP3LineName, OBJPROP_RAY_RIGHT, true);
               ObjectSetInteger(0, g_PartialTP3LineName, OBJPROP_SELECTABLE, false);
               ObjectSetString(0, g_PartialTP3LineName, OBJPROP_TEXT, "TP3: " + DoubleToString(exitPercent3, 0) + "% @ +" + DoubleToString(calc.partialPips3, 1) + " pips");
            }
            else
            {
               ObjectMove(0, g_PartialTP3LineName, 0, currentTime, calc.partialTP3Price);
               ObjectMove(0, g_PartialTP3LineName, 1, futureTime, calc.partialTP3Price);
               ObjectSetString(0, g_PartialTP3LineName, OBJPROP_TEXT, "TP3: " + DoubleToString(exitPercent3, 0) + "% @ +" + DoubleToString(calc.partialPips3, 1) + " pips");
            }
         }
         else
         {
            // Delete TP3 line if it exists but 2 levels selected
            if(ObjectFind(0, g_PartialTP3LineName) >= 0)
               ObjectDelete(0, g_PartialTP3LineName);
         }
         
         // Delete standard TP line if it exists
         if(ObjectFind(0, g_TPLineName) >= 0)
            ObjectDelete(0, g_TPLineName);
      }
      else
      {
         // Standard TP line
         if(ObjectFind(0, g_TPLineName) < 0)
         {
            ObjectCreate(0, g_TPLineName, OBJ_TREND, 0, currentTime, calc.tpPrice, futureTime, calc.tpPrice);
            ObjectSetInteger(0, g_TPLineName, OBJPROP_COLOR, inpTPLineColor);
            ObjectSetInteger(0, g_TPLineName, OBJPROP_WIDTH, 2);
            ObjectSetInteger(0, g_TPLineName, OBJPROP_STYLE, STYLE_SOLID);
            ObjectSetInteger(0, g_TPLineName, OBJPROP_RAY_RIGHT, true);
            ObjectSetInteger(0, g_TPLineName, OBJPROP_SELECTABLE, false);
            ObjectSetString(0, g_TPLineName, OBJPROP_TEXT, "TP: " + DoubleToString(calc.tpPips, 1) + " pips");
         }
         else
         {
            ObjectMove(0, g_TPLineName, 0, currentTime, calc.tpPrice);
            ObjectMove(0, g_TPLineName, 1, futureTime, calc.tpPrice);
         }
         
         // Delete partial exit lines if they exist
         if(ObjectFind(0, g_PartialTP1LineName) >= 0)
            ObjectDelete(0, g_PartialTP1LineName);
         if(ObjectFind(0, g_PartialTP2LineName) >= 0)
            ObjectDelete(0, g_PartialTP2LineName);
         if(ObjectFind(0, g_PartialTP3LineName) >= 0)
            ObjectDelete(0, g_PartialTP3LineName);
      }
   }
   
   // Entry Line
   if(inpShowEntryLine)
   {
      if(ObjectFind(0, g_EntryLineName) < 0)
      {
         ObjectCreate(0, g_EntryLineName, OBJ_TREND, 0, currentTime, calc.entryPrice, futureTime, calc.entryPrice);
         ObjectSetInteger(0, g_EntryLineName, OBJPROP_COLOR, inpEntryLineColor);
         ObjectSetInteger(0, g_EntryLineName, OBJPROP_WIDTH, 2);
         ObjectSetInteger(0, g_EntryLineName, OBJPROP_STYLE, STYLE_DOT);
         ObjectSetInteger(0, g_EntryLineName, OBJPROP_RAY_RIGHT, true);
         ObjectSetInteger(0, g_EntryLineName, OBJPROP_SELECTABLE, false);
         string entryLabel = (inpDisplayMode == DISPLAY_CONSERVATIVE) ? "Entry (w/ Slippage)" : "Entry";
         ObjectSetString(0, g_EntryLineName, OBJPROP_TEXT, entryLabel);
      }
      else
      {
         ObjectMove(0, g_EntryLineName, 0, currentTime, calc.entryPrice);
         ObjectMove(0, g_EntryLineName, 1, futureTime, calc.entryPrice);
      }
   }
   
   // Break-even Line
   if(inpShowBreakEvenLine)
   {
      double bePrice = calc.entryPrice + (calc.breakEvenPips * g_PipValue);
      
      if(ObjectFind(0, g_BELineName) < 0)
      {
         ObjectCreate(0, g_BELineName, OBJ_TREND, 0, currentTime, bePrice, futureTime, bePrice);
         ObjectSetInteger(0, g_BELineName, OBJPROP_COLOR, inpBELineColor);
         ObjectSetInteger(0, g_BELineName, OBJPROP_WIDTH, 1);
         ObjectSetInteger(0, g_BELineName, OBJPROP_STYLE, STYLE_DASH);
         ObjectSetInteger(0, g_BELineName, OBJPROP_RAY_RIGHT, true);
         ObjectSetInteger(0, g_BELineName, OBJPROP_SELECTABLE, false);
         ObjectSetString(0, g_BELineName, OBJPROP_TEXT, "BE: " + DoubleToString(calc.breakEvenPips, 2) + " pips");
      }
      else
      {
         ObjectMove(0, g_BELineName, 0, currentTime, bePrice);
         ObjectMove(0, g_BELineName, 1, futureTime, bePrice);
      }
   }
}

//+------------------------------------------------------------------+
//| Delete Lines                                                      |
//+------------------------------------------------------------------+
void DeleteLines()
{
   ObjectDelete(0, g_SLLineName);
   ObjectDelete(0, g_TPLineName);
   ObjectDelete(0, g_EntryLineName);
   ObjectDelete(0, g_BELineName);
   ObjectDelete(0, g_PartialTP1LineName);
   ObjectDelete(0, g_PartialTP2LineName);
   ObjectDelete(0, g_PartialTP3LineName);
}
